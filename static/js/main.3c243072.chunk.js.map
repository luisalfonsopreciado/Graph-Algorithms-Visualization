{"version":3,"sources":["components/Footer/Footer.module.css","components/Navigation/NavigationItems/NavigationItem/NavigationItem.module.css","App.module.css","components/Navigation/Toolbar/Toolbar.module.css","resources/logos/github.png","info lazy /^/.//.*/.md$/ groupOptions: {} namespace object","components/Cell/Cell.js","utility/MazeGenerators/Contour.js","utility/MazeGenerators/RecursiveDivision.js","utility/generateGraph.js","utility/DS/Queue.js","utility/DS/DisjointSet.js","utility/Node.js","utility/DS/Graph.js","utility/DS/MinHeap.js","utility/constants.js","utility/Algorithms/floydWarshall.js","hooks/useNodeGrid.js","components/Navigation/NavigationItems/NavigationItem/NavigationItem.js","components/Navigation/NavigationItems/Dropdown/DropDown.js","components/Navigation/NavigationItems/Subnav/Subnav.js","components/Navigation/NavigationItems/Dropdown/DropItem/DropItem.js","hooks-store/store.js","components/Navigation/NavigationItems/NavigationItems.js","components/Navigation/Toolbar/Toolbar.js","components/Board.js","utility/MazeGenerators/Random.js","components/UI/Backdrop/Backdrop.js","components/UI/CustomDialog/CustomDialog.js","components/Footer/Footer.js","hooks-store/algorithm.js","App.js","index.js"],"names":["module","exports","map","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","then","e","Error","code","ids","id","t","keys","Object","Cell","node","mouse","numRows","numCols","classes","useEffect","setClasses","row","Math","floor","col","push","className","join","onMouseDown","onMouseEnter","onMouseLeave","onMouseUp","drawContourWalls","grid","type","i","add","length","j","divide","width","height","orientation","prohibited","horizontal","whereCol","randBetween","whereRow","passCol","passRow","drawWall","updateProhibitedCells","newwidth","newheight","neworientation","chooseOrientation","startRow","startCol","cell","isKeyValue","min","max","random","generateNodeGrid","nodesGrid","graph","Graph","document","getElementsByClassName","addVertex","getKeyNodes","startNode","targetNode","currentNode","is","remove","generateGraph","neighbors","getNeighbors","addEdge","dist","Queue","this","items","element","isEmpty","shift","str","DisjointSet","setParent","child","parent","weight","getWeight","num","findParent","hasCycle","v1","v2","p1","p2","union","Array","fill","parent1","parent2","Node","predecessor","Infinity","g","h","f","cellNotInGraph","end","isNeighbor","s","getElementById","classList","markShortestPath","forEach","item","name","contains","getNode","nodeGrid","noOfVertices","AdjList","Map","v","set","w","get","get_keys","get_values","conc","console","log","startingNode","withAnimation","animations","visited","q","enqueue","getQueueElement","dequeue","get_List","n","neigh","markSearched2Done","DFSUtil","vert","get_neighbours","get_elem","hasSecond","heap","MinHeap","pop","adjacentNode","tentativeDistance","manhattanDistance","currentdist","adj","tentativeGScore","abs","greedyHeuristic","a","d","sqrt","pow","queue","neighbor","mst","adjacentNodes","toString","el","ds","edges","arr","key","edgeId","sort","b","hasOwnProperty","nodes","currentEdge","values","filter","selector","parentIndex","parentVal","pushedVal","swap","ret","temp","rightChildIndex","leftChildIndex","lowest","includes","indexOf","GREEDY_BFS","BFS","DFS","PRIMS","KRUSKAL","ALG_TITLE","useNodeGrid","rows","cols","useState","setNumRows","setNumCols","useCallback","clearGrid","reset","resetGrid","removeVisuals","paintInDistance","removeClasses","resetDistance","NavigationItem","children","clicked","style","onClick","Btn","DropDown","title","Subnav","DropItem","globalState","listeners","actions","useStore","shouldListen","setState","dispatch","actionId","payload","newPortfolio","listener","li","NavigationItems","executeAlgorithm","algorithm","mazeGen","setSpeed","openDialog","clear","setUserAction","info","algo","cts","color","toolbar","props","Toolbar","pathMtrx","useStyles","makeStyles","paper","padding","margin","marginTop","marginBottom","React","memo","isMouseDown","setIsMouseDown","animating","setIsAnimating","isMovingTarget","setIsMovingTarget","isMovingSecondTarget","setIsMovingSecondTarget","isMovingStart","setIsMovingStart","settingSecondTarget","setSettingSecondTarget","hasSecondTarget","setHasSecondTarget","numTargets","setNumTargets","prevAlgorithm","setPrevAlgorithm","userAction","animationSpeed","setAnimationSpeed","distance","setDistance","matrix","setMatrix","handleKeyNodeMove","setAsTarget","util","Dijkstra","AStar","bestFirstSearch","DStar","Prims","drawPath","bellmanFord","onMouseEnterHandler","setAsSecondTarget","setWall","onMouseDownHandler","onMouseLeaveHandler","removeClass","onMouseUpHandler","Grid","rowNum","val","colNum","bfs","dfs","dijkstra","aStar","dStar","floydWarshall","mtrx","path","startId","targetId","start","getDistanceTo","k","Kruskal","kruskal","finalPath","u","result","getPath","prevNode","nodeId","removeVisualization","animate","count","intervalId","setInterval","markSearched","clearInterval","obj","prohibitedCells","board","Paper","gridTemplateRows","gridTemplateColumns","prevProps","nextProps","backdrop","cssClasses","show","CustomDialog","isOpen","handleClose","subtitle","howToPlay","Dialog","fullWidth","maxWidth","open","onClose","aria-labelledby","DialogTitle","DialogContent","DialogContentText","DialogActions","Button","Footer","IconContainer","Icons","listStyle","href","rel","target","src","github","alt","configureStore","userActions","initialState","SET_ALGO","state","action","SET_INFO","configureAlgorithmStore","App","setIsOpen","markdown","setMarkdown","fetch","default","res","text","marked","getMarkdown","handleDialogOpen","styles","elevation","dangerouslySetInnerHTML","__html","customDialog","ReactDOM","render","StrictMode","process"],"mappings":"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","file":"static/js/main.3c243072.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"Footer\":\"Footer_Footer__238hM\",\"Icons\":\"Footer_Icons__3PTSJ\",\"IconContainer\":\"Footer_IconContainer__2erq5\",\"FooterTitle\":\"Footer_FooterTitle__1Ygxr\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"NavigationItem\":\"NavigationItem_NavigationItem__2SpXc\",\"Btn\":\"NavigationItem_Btn__3xhRr\",\"navbar\":\"NavigationItem_navbar__2rE4b\",\"NavigationItem-content\":\"NavigationItem_NavigationItem-content__2c_Zw\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"App\":\"App_App__16ZpL\",\"Container\":\"App_Container__10KOh\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Toolbar\":\"Toolbar_Toolbar__ApScI\"};","module.exports = \"data:image/png;base64,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\"","var map = {\n\t\"./A*.md\": [\n\t\t76,\n\t\t3\n\t],\n\t\"./Bellman-Ford.md\": [\n\t\t77,\n\t\t4\n\t],\n\t\"./Breadth First Search.md\": [\n\t\t78,\n\t\t5\n\t],\n\t\"./Contour Walls.md\": [\n\t\t79,\n\t\t6\n\t],\n\t\"./D*.md\": [\n\t\t80,\n\t\t7\n\t],\n\t\"./Depth First Search.md\": [\n\t\t81,\n\t\t8\n\t],\n\t\"./Dijkstra.md\": [\n\t\t82,\n\t\t9\n\t],\n\t\"./Floyd-Warshall.md\": [\n\t\t83,\n\t\t10\n\t],\n\t\"./Greedy Best First Search.md\": [\n\t\t84,\n\t\t11\n\t],\n\t\"./Kruskal's Algorithm.md\": [\n\t\t85,\n\t\t12\n\t],\n\t\"./Prim's Algorithm.md\": [\n\t\t86,\n\t\t13\n\t],\n\t\"./Random Maze.md\": [\n\t\t87,\n\t\t14\n\t],\n\t\"./Recursive Division.md\": [\n\t\t88,\n\t\t15\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(function() {\n\t\treturn __webpack_require__.t(id, 7);\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 72;\nmodule.exports = webpackAsyncContext;","import React, { useEffect } from \"react\";\nimport \"./Cell.css\";\n\nconst Cell = ({ node, mouse, numRows, numCols }) => {\n  let classes = [\"Cell\"];\n  let icon = null;\n\n  useEffect(() => node.setClasses(), [node]);\n\n  if (node.row === Math.floor(numRows/2) && node.col === Math.floor((numCols * 1) / 3)) {\n    classes.push(\"Start\");\n  }\n  if (node.row === Math.floor(numRows/2) && node.col === Math.floor((numCols * 2) / 3)) {\n    classes.push(\"Target\");\n  }\n\n  return (\n    <div\n      className={classes.join(\" \")}\n      id={`${node.row} ${node.col}`}\n      onMouseDown={() => mouse.onMouseDown(node)}\n      onMouseEnter={() => mouse.onMouseEnter(node)}\n      onMouseLeave={() => mouse.onMouseLeave(node)}\n      onMouseUp={() => mouse.onMouseUp(node)}\n    >\n      {icon}\n    </div>\n  );\n};\n\nexport default Cell;\n","export const drawContourWalls = (grid, type) => {\n  for (let i in grid) {\n    grid[i][0].add(type);\n    grid[i][grid[i].length - 1].add(type);\n  }\n\n  for (let j in grid[0]) {\n    grid[0][j].add(type);\n    grid[grid.length - 1][j].add(type);\n  }\n};\n","import { drawContourWalls } from \"./Contour\";\n\n// Constants to avoid typo's\nconst HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\n\nexport const recursiveDivision = (grid, type) => {\n  drawContourWalls(grid, type);\n  const width = grid[0].length - 2; // Subtract 2 since we drew a contour\n  const height = grid.length - 2;\n  let prohibitedCells = []; // Walls that clot the maze\n\n  divide(1,1,width, height, chooseOrientation(width, height), prohibitedCells, grid, type)\n\n  // Remove prohibited cells so that all of the board is reachable\n  for (let i in prohibitedCells) {\n    const row = prohibitedCells[i][0];\n    const col = prohibitedCells[i][1];\n    grid[row][col].remove([type]);\n  }\n};\n\nconst divide = (\n  row,\n  col,\n  width,\n  height,\n  orientation,\n  prohibited,\n  grid,\n  type\n) => {\n  if (width <= 2 || height <= 2) return; //Maybe have a function that paints?\n  // Is the wall to be drawn horizontal?\n  const horizontal = orientation === HORIZONTAL;\n\n  // Where will the wall be drawn from?\n  let whereCol = col + (horizontal ? 0 : randBetween(2, width - 2)); // Rand number between the col and width\n  let whereRow = row + (horizontal ? randBetween(2, height - 2) : 0); // Rand number between the row and height\n\n  // Where will the passage through the wall exist?\n  const passCol = whereCol + (horizontal ? randBetween(0, width - 1) : 0); // Rand number between the col and width\n\n  const passRow = whereRow + (horizontal ? 0 : randBetween(0, height - 1)); // Rand number between the row and height\n\n  // How long will the wall be?\n  const length = horizontal ? width : height;\n\n  // Draw the walls\n  drawWall(whereRow, whereCol, horizontal, length, grid, type);\n  updateProhibitedCells(passRow, passCol, horizontal, prohibited);\n\n  // get first recursive call data\n  let newwidth = horizontal ? width : whereCol - col;\n  let newheight = horizontal ? whereRow - row : height;\n  let neworientation = chooseOrientation(newwidth, newheight);\n  \n  divide(row, col, newwidth, newheight, neworientation, prohibited,grid, type);\n  \n  // get second recursive call data\n  let newCol = horizontal ? col : whereCol + 1;\n  let newRow = horizontal ? whereRow + 1 : row;\n\n  newwidth = horizontal ? width : col + width - whereCol - 1;\n  newheight = horizontal ? row + height - whereRow - 1: height;\n  neworientation = chooseOrientation(newwidth, newheight);\n\n  divide(newRow, newCol, newwidth, newheight, neworientation, prohibited,grid, type);\n};\n\nconst drawWall = (startRow, startCol, horizontal, length, grid,type) => {\n  for (let i = 0; i < length; i++) {\n    const row = startRow + (horizontal ? 0 : i);\n    const col = startCol + (horizontal ? i : 0);\n\n    const cell = grid[row][col];\n    if (!cell.isKeyValue()) cell.add([type]);\n  }\n};\n\nconst chooseOrientation = (width, height) => {\n  if (width < height) return HORIZONTAL;\n  return VERTICAL;\n};\n\nconst updateProhibitedCells = (row, col, horizontal, prohibited) => {\n  prohibited.push([row, col]);\n  if (!horizontal) {\n    prohibited.push([row, col + 1]);\n    prohibited.push([row, col - 1]);\n  } else {\n    prohibited.push([row + 1, col]);\n    prohibited.push([row - 1, col]);\n  }\n};\n\n// stack overflow https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript\nfunction randBetween(min, max) {\n  // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n","import { Graph } from \"./index\";\n\nexport const calculateNumVertices = () => {\n  const numCells = document.getElementsByClassName(\"Cell\").length;\n  const numWalls = document.getElementsByClassName(\"Wall\").length;\n  return numCells - numWalls;\n};\n\nexport const generateNodeGrid = (grid) => {\n  const nodesGrid = [];\n  const graph = new Graph(calculateNumVertices());\n\n  for (let row in grid) {\n    nodesGrid[row] = [];\n    for (let col in grid[row]) {\n      graph.addVertex(grid[row][col]);\n    }\n  }\n  return graph;\n};\n\nexport const getKeyNodes = (nodesGrid) => {\n  let startNode = null;\n  let targetNode = null;\n\n  for (let row = 0; row < nodesGrid.length; row++) {\n    for (let col = 0; col < nodesGrid[row].length; col++) {\n      const currentNode = nodesGrid[row][col];\n      if (currentNode.is(\"ShortestPath\")) {\n        currentNode.remove([\"ShortestPath\"]);\n        currentNode.add(\"Searched2Done\");\n      }\n      if (currentNode.is(\"Start\")) startNode = currentNode;\n      if (currentNode.is(\"Target\")) targetNode = currentNode;\n    }\n  }\n  return { startNode, targetNode };\n};\n\nexport const generateGraph = (nodesGrid) => {\n  let startNode = null;\n  let targetNode = null;\n\n  const graph = generateNodeGrid(nodesGrid);\n\n  for (let row = 0; row < nodesGrid.length; row++) {\n    for (let col = 0; col < nodesGrid[row].length; col++) {\n      const currentNode = nodesGrid[row][col];\n\n      if (!currentNode.is(\"Wall\")) {\n        if (currentNode.is(\"Start\")) startNode = currentNode;\n        if (currentNode.is(\"Target\")) targetNode = currentNode;\n        const neighbors = currentNode.getNeighbors(nodesGrid);\n\n        for (let i in neighbors) {\n          graph.addEdge(currentNode, neighbors[i]);\n        }\n      }\n    }\n  }\n  if (startNode) startNode.dist = 0;\n  return { graph, startNode, targetNode };\n};\n","export class Queue {\n\n  constructor() {\n    this.items = [];\n  }\n\n  enqueue(element) {\n    this.items.push(element);\n  }\n\n  dequeue() {\n    if (this.isEmpty()) return \"Underflow\";\n    return this.items.shift();\n  }\n\n  front() {\n    if (this.isEmpty()) return \"No elements in Queue\";\n    return this.items[0];\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  printQueue() {\n    var str = \"\";\n    for (var i = 0; i < this.items.length; i++) str += this.items[i] + \" \";\n    return str;\n  }\n}\n","/*\n    Disjoing set data structure (Array representation).\n\n    1. Initially instantiate the array with the number of vertices in the graph. Fill the array\n    with -1, this indicates that each vertices is a set with itself as a parent.\n\n    Performing a union\n    set the parent of one set to point at the parent of the second set and adjust \n    the new parent weight.\n*/\n\nexport class DisjointSet {\n  constructor(length) {\n    this.items = new Array(length).fill(-1);\n  }\n\n  setParent = (child, parent) => {\n    const weight = this.getWeight(child);\n    this.items[child] = parent;\n    this.items[parent] += weight;\n  };\n\n  getWeight = (num) => this.items[num];\n\n  findParent = (num) => {\n    if (this.items[num] < 0) return num;\n    return this.findParent(this.items[num]);\n  };\n\n  // If there exists a cycle return true\n  // else unite the graph and return false\n  hasCycle = (v1, v2) => {\n    const p1 = this.findParent(v1);\n    const p2 = this.findParent(v2);\n    if (p1 === p2 && p1 > 0) return true;\n    this.union(p1, p2);\n    return false;\n  };\n\n  // Takes two parent nodes and merges them to\n  // creates one set\n  union(parent1, parent2) {\n    const p1Weight = this.getWeight(parent1);\n    const p2Weight = this.getWeight(parent2);\n    p1Weight <= p2Weight\n      ? this.setParent(parent2, parent1)\n      : this.setParent(parent1, parent2);\n  }\n}\n","export default class Node {\n  constructor(row, col, id) {\n    this.row = row;\n    this.col = col;\n    this.id = id;\n    this.predecessor = null;\n    this.dist = Infinity;\n    this.g = 1;\n    this.h = null;\n    this.f = Infinity;\n  }\n\n  getNeighbors(grid) {\n    const cellNotInGraph = (row, col) => {\n      return grid[row][col].is(\"Wall\");\n    };\n\n    if (this.is(\"Wall\")) return [];\n    let neighbors = [];\n\n    if (this.row > 0 && !cellNotInGraph(this.row - 1, this.col)) {\n      // N\n      neighbors.push(grid[this.row - 1][this.col]);\n    }\n    if (this.col > 0 && !cellNotInGraph(this.row, this.col - 1)) {\n      // W\n      neighbors.push(grid[this.row][this.col - 1]);\n    }\n    if (this.row < grid.length - 1 && !cellNotInGraph(this.row + 1, this.col)) {\n      // S\n      neighbors.push(grid[this.row + 1][this.col]);\n    }\n    if (\n      this.col < grid[this.row].length - 1 &&\n      !cellNotInGraph(this.row, this.col + 1)\n    ) {\n      // E\n      neighbors.push(grid[this.row][this.col + 1]);\n    }\n\n    return neighbors;\n  }\n\n  isNeighbor(node) {\n    // O(1)\n    if (this.row === node.row)\n      return this.col + 1 === node.col || this.col - 1 === node.col;\n    if (this.col === node.col)\n      return this.row + 1 === node.row || this.row - 1 === node.row;\n    return false;\n  }\n\n  getDistanceTo(end) {\n    // O(1)\n    if (this === end) return 0;\n    if (!this.isNeighbor(end)) return Infinity;\n    return this.getWeight() + end.getWeight() - 1;\n  }\n\n  getWeight() {\n    if (this.is(\"Weight\")) return 15;\n    if (this.is(\"Wall\")) return Infinity;\n    return 1;\n  }\n\n  removeClass(s) {\n    this.classes.remove(s);\n  }\n\n  setClasses() {\n    this.cell = document.getElementById(`${this.row} ${this.col}`);\n    this.classes = this.cell.classList;\n  }\n\n  toString() {\n    return \"(\" + this.row + \" \" + this.col + \")\";\n  }\n\n  setWall() {\n    if (this.isKeyValue()) return;\n    this.remove([\"Searched\", \"Searched2\"]);\n    this.add(\"Wall\");\n  }\n\n  setAsTarget() {\n    this.add(\"Target\");\n    this.markShortestPath();\n  }\n\n  setAsSecondTarget() {\n    this.remove(\"Wall\");\n    this.add(\"SecondaryTarget\");\n  }\n\n  markSearched() {\n    if (this.is(\"Target\")) return;\n    this.add(\"Searched\");\n  }\n\n  markSearched2() {\n    if (this.is(\"Target\")) return;\n    this.add(\"Searched2\");\n  }\n\n  markSearched2Done() {\n    if (this.is(\"Target\") || this.is(\"Start\")) return;\n    this.add(\"Searched2Done\");\n  }\n\n  removeVisuals() {\n    this.remove([\"ShortestPath\", \"Searched\", \"Searched2\", \"Searched2Done\"]);\n    this.predecessor = null;\n    this.dist = Infinity;\n  }\n\n  removeClasses() {\n    this.classes.forEach(\n      (item) =>\n        item !== \"Cell\" &&\n        item !== \"Wall\" &&\n        item !== \"Weight\" &&\n        this.classes.remove(item)\n    );\n  }\n\n  reset() {\n    this.remove([\"ShortestPath\", \"Wall\", \"Searched\"]);\n    this.remove([\"Searched2\", \"SecondaryTarget\", \"Searched2Done\"]);\n    this.remove([\"Weight\"]);\n    this.predecessor = null;\n    this.dist = Infinity;\n  }\n\n  isKeyValue() {\n    return this.is(\"Target\") || this.is(\"Start\") || this.is(\"SecondaryTarget\");\n  }\n\n  markShortestPath() {\n    if (!this.is(\"Target\") && !this.is(\"Start\")) {\n      this.remove([\"Searched\", \"Searched2\", \"Searched2Done\"]);\n      this.add(\"ShortestPath\");\n    }\n    if (this.predecessor !== null) {\n      this.predecessor.markShortestPath();\n    }\n  }\n\n  remove(classes) {\n    for (let i in classes) this.classes.remove(classes[i]);\n  }\n\n  is(name) {\n    return this.classes.contains(name);\n  }\n\n  add(name) {\n    this.classes.add(name);\n  }\n\n  clear() {\n    this.classes = [\"Cell\"];\n  }\n}\n\n// returns a reference to the node given the id\nNode.getNode = (id, nodeGrid) => {\n  // O(1)\n  const width = nodeGrid[0].length;\n  const row = Math.floor((id - 1) / width);\n  const col = (id - 1) % width;\n  return nodeGrid[row][col];\n};\n","import { Queue } from \"./Queue\";\nimport { DisjointSet } from \"./DisjointSet\";\nimport { MinHeap } from \"../index\";\nimport Node from \"../Node\";\n\n/**\n * A graph ADT implementation\n */\nexport class Graph {\n  constructor(noOfVertices) {\n    this.noOfVertices = noOfVertices;\n    this.AdjList = new Map();\n  }\n\n  /**\n   * Adds a vertex object to the graph\n   *\n   * @param {*} v  Vertex Object\n   */\n  addVertex(v) {\n    // initialize the adjacent list with a\n    // null array\n    this.AdjList.set(v, []);\n  }\n\n  /**\n   * Adds an Edge to the graph\n   *\n   * @param {*} v start Vertex\n   * @param {*} w end Vertex\n   */\n  addEdge(v, w) {\n    // get the list for vertex v and put the\n    // vertex w denoting edge between v and w\n    this.AdjList.get(v).push(w);\n    // Since graph is undirected,\n    // add an edge from w to v also\n    this.AdjList.get(w).push(v);\n  }\n\n  /**\n   * Print the current graph instance\n   */\n  printGraph() {\n    // get all the vertices\n    let get_keys = this.AdjList.keys();\n\n    // iterate over the vertices\n    for (let i of get_keys) {\n      // great the corresponding adjacency list\n      // for the vertex\n      let get_values = this.AdjList.get(i);\n      let conc = \"\";\n\n      // iterate over the adjacency list\n      // concatenate the values into a string\n      for (let j of get_values) conc += j + \" \";\n\n      // print the vertex and its adjacency list\n      console.log(i + \" -> \" + conc);\n    }\n  }\n\n  /**\n   * Perform Breadth First Search on the graph\n   *\n   * @param {*} startingNode Reference to the starting node\n   * @param {*} withAnimation Boolean indicating if animations are needed\n   */\n  bfs(startingNode, withAnimation) {\n    // Array to store the animations\n    const animations = [];\n\n    // Create a visited array\n    let visited = [];\n    for (let i = 0; i < this.noOfVertices; i++) visited[i] = false;\n\n    // Create an object for queue\n    let q = new Queue();\n\n    // add the starting node to the queue\n    visited[startingNode] = true;\n    q.enqueue(startingNode);\n\n    // loop until queue is element\n    while (!q.isEmpty()) {\n      // get the element from the queue\n      let getQueueElement = q.dequeue();\n\n      // passing the current vertex to callback funtion\n      // get the adjacent list for current vertex\n      let get_List = this.AdjList.get(getQueueElement);\n\n      // loop through the list and add the element to the\n      // queue if it is not processed yet\n      for (let n in get_List) {\n        let neigh = get_List[n];\n\n        if (!visited[neigh]) {\n          neigh.predecessor = getQueueElement;\n          neigh.dist = 1 + getQueueElement.dist;\n          if (!withAnimation) neigh.markSearched2Done();\n          if (neigh.is(\"Target\") && !withAnimation) neigh.markShortestPath();\n          animations.push(neigh);\n          visited[neigh] = true;\n          q.enqueue(neigh);\n        }\n      }\n    }\n\n    return animations;\n  }\n\n  /**\n   * Perform a Depth First Search on the graph\n   *\n   * @param {*} startingNode Reference to the starting node\n   * @param {*} withAnimation Boolean indicating if animations are desired\n   */\n  dfs(startingNode, withAnimation) {\n    if (!startingNode) return [];\n    const animations = [];\n\n    let visited = [];\n    for (let i = 0; i < this.noOfVertices; i++) visited[i] = false;\n\n    this.DFSUtil(startingNode, visited, animations, withAnimation);\n\n    return withAnimation ? animations : [];\n  }\n\n  /**\n   *\n   * Depth First search recursive utility function: process and explore\n   * all the adjacent vertices of the input vertex\n   *\n   * @param {*} vert Reference to the starting node\n   * @param {*} visited Boolean of arrays indicating if a vertex has been visited\n   * @param {*} animations Array that holds the algorithm's animations\n   * @param {*} withAnimation Boolean indicating if animation is desired\n   */\n  DFSUtil(vert, visited, animations, withAnimation) {\n    visited[vert] = true;\n\n    let get_neighbours = this.AdjList.get(vert);\n\n    for (let i in get_neighbours) {\n      let get_elem = get_neighbours[i];\n      get_elem.dist = vert.dist + 1;\n      if (!visited[get_elem]) {\n        get_elem.predecessor = vert;\n        if (!withAnimation) get_elem.markSearched2Done();\n\n        if (get_elem.is(\"Target\") && !withAnimation) {\n          get_elem.markShortestPath();\n        }\n        animations.push(get_elem);\n        this.DFSUtil(get_elem, visited, animations, withAnimation);\n      }\n    }\n  }\n\n  /**\n   *\n   * Perform Dijkstra's Algorithm on the graph.\n   *\n   * @param {*} startNode Reference to the starting node\n   * @param {*} animations Array that will store the algorithm's animations\n   * @param {*} hasSecond Boolean indicating if there is targets in the graph\n   * @param {*} withAnimation Boolean indicating if animation is desired\n   */\n  dijkstra(startNode, animations, hasSecond, withAnimation) {\n    if (!startNode) return [];\n\n    // Prioritize based on the node's distance\n    const heap = new MinHeap((item) => item.dist);\n\n    heap.push(startNode);\n\n    while (!heap.isEmpty()) {\n      // Get the node with lowest distance\n      const currentNode = heap.pop();\n\n      // If we have found the target return the animations\n      if (currentNode.is(\"Target\")) {\n        if (!withAnimation) currentNode.markShortestPath();\n        return animations;\n      }\n\n      // Get neighbors\n      let neighbors = this.AdjList.get(currentNode);\n\n      // For each of neighbors\n      for (let adjacentNode of neighbors) {\n        // Calculate distance via the neighbor\n        let tentativeDistance = adjacentNode.getWeight() + currentNode.dist;\n\n        if (tentativeDistance < adjacentNode.dist) {\n          // Path via neighbor is better, so record it.\n\n          // Handle animations\n          if (!withAnimation) adjacentNode.markSearched2Done();\n          animations.push(adjacentNode);\n\n          heap.push(adjacentNode);\n\n          // Update the parent\n          adjacentNode.predecessor = currentNode;\n\n          // Update the distance\n          adjacentNode.dist = tentativeDistance;\n        }\n      }\n    }\n\n    // We did not find the target\n    return animations;\n  }\n\n  /**\n   * Perform A* Algorithm to the graph\n   *\n   * @param {*} startNode Reference to the starting node\n   * @param {*} targetNode Reference to the target node\n   * @param {*} withAnimation Boolean indicating if animations are desired\n   */\n  aStar(startNode, targetNode, withAnimation) {\n    if (startNode === null) return [];\n    if (targetNode === null) return [];\n\n    // Array to store nodes to animate\n    const animations = [];\n\n    // Prioritize based on the f parameter\n    const heap = new MinHeap((item) => item.f);\n\n    // g is zero for the start and Infinity for the rest of nodes\n    startNode.f = this.manhattanDistance(startNode, targetNode);\n\n    heap.push(startNode);\n\n    while (!heap.isEmpty()) {\n      // Get node in the priority queue having the lowest f value\n      const currentNode = heap.pop();\n\n      // The current distance of the currentNode\n      let currentdist = currentNode.dist;\n\n      // Get neighbors\n      let adj = this.AdjList.get(currentNode);\n\n      // Handle animations\n      if (!withAnimation) currentNode.markSearched2Done();\n      animations.push(currentNode);\n\n      if (currentNode.is(\"Target\")) {\n        if (!withAnimation) currentNode.markShortestPath();\n        return animations;\n      }\n\n      //for each of its adjacent nodes...\n      for (let adjacentNode of adj) {\n        // distance(current,neighbor) is the weight of the edge from current to neighbor\n        // tentativeGScore  is the distance from start to the neighbor through current\n        let tentativeGScore = currentdist + adjacentNode.getWeight();\n\n        if (tentativeGScore < adjacentNode.dist) {\n          // This path to neighbor is better than any previous one. Record it!\n\n          //reference parent\n          adjacentNode.predecessor = currentNode;\n\n          adjacentNode.dist = tentativeGScore;\n\n          // Set f value\n          const g = adjacentNode.dist;\n\n          const h = this.manhattanDistance(adjacentNode, targetNode);\n\n          adjacentNode.f = g + h;\n\n          heap.push(adjacentNode);\n        }\n      }\n    }\n\n    // We did not find the target\n    return animations;\n  }\n\n  /**\n   * Returns the ManhattanDistance between two graph nodes\n   *\n   * @param {*} node first node\n   * @param {*} targetNode second node\n   */\n  manhattanDistance(node, targetNode) {\n    return (\n      Math.abs(node.col - targetNode.col) + Math.abs(node.row - targetNode.row)\n    );\n  }\n  /**\n   * Perform Greedy Best First search on the graph\n   *\n   * @param {*} startNode Reference to the starting node\n   * @param {*} targetNode Reference to the target node\n   * @param {*} withAnimation Boolean indicating if animations are desired\n   */\n  bestFirstSearch(startNode, targetNode, withAnimation) {\n    if (startNode === null) return [];\n    if (targetNode === null) return [];\n\n    // Map to store visited nodes\n    const visited = {};\n\n    // Array to store the animations\n    const animations = [];\n\n    // Create Empty Priority Queue\n    const heap = new MinHeap((item) => item.f);\n\n    startNode.g = 0;\n    this.greedyHeuristic(startNode, targetNode);\n\n    // Insert start in priority queue\n    heap.push(startNode);\n\n    while (!heap.isEmpty()) {\n      // Remove vertex with smallest cost\n      const currentNode = heap.pop();\n\n      // Check if currentNode is target and handle animations\n      if (currentNode.is(\"Target\")) {\n        animations.push(currentNode);\n        if (!withAnimation) currentNode.markShortestPath();\n        return animations;\n      }\n\n      let currentdist = currentNode.dist;\n\n      // Get neighbors of currentNode\n      let adj = this.AdjList.get(currentNode);\n\n      // Handle animations\n      if (!withAnimation) currentNode.markSearched2Done();\n      animations.push(currentNode);\n\n      //for each adjacent node\n      for (let a in adj) {\n        const adjacentNode = adj[a];\n\n        //choose nearest node with lowest *total* cost\n        let d = adjacentNode.getWeight() + currentdist;\n\n        // if the vertex is unvisited and distance is improved\n        if (!(adjacentNode.id in visited) && d < adjacentNode.dist) {\n          this.greedyHeuristic(adjacentNode, targetNode);\n\n          if (!heap.contains(adjacentNode)) heap.push(adjacentNode);\n\n          // Update the parent and distance\n          adjacentNode.predecessor = currentNode;\n          adjacentNode.dist = d;\n\n          // Mark as visited\n          visited[adjacentNode.id] = true;\n        }\n      }\n    }\n\n    // We did not find the target\n    return animations;\n  }\n\n  /**\n   * Update Greedy Heurisitc on two input nodes\n   *\n   * @param {*} node\n   * @param {*} targetNode\n   */\n  greedyHeuristic(node, targetNode) {\n    // Calculate the Euclidean distance between the node and target\n    const h = Math.sqrt(\n      Math.pow(node.col - targetNode.col, 2) +\n        Math.pow(node.row - targetNode.row, 2)\n    );\n    node.h = Math.floor(h);\n    node.f = node.h;\n  }\n\n  /**\n   * Update Euclidean distance between two nodes\n   *\n   * @param {*} node\n   * @param {*} targetNode\n   */\n  euclideanDistance(node, targetNode) {\n    const h = Math.sqrt(\n      Math.pow(node.col - targetNode.col, 2) +\n        Math.pow(node.row - targetNode.row, 2)\n    );\n    node.h = Math.floor(h);\n    node.f = node.getWeight() + node.h;\n  }\n\n  /**\n   * Perform D* Algorithm on the graph\n   *\n   * @param {*} startNode Reference to start node\n   * @param {*} targetNode Reference to target node\n   * @param {*} withAnimation Boolean indicating if animations are desired\n   */\n  dStar(startNode, targetNode, withAnimation) {\n    if (targetNode === null) return [];\n\n    const queue = new Queue();\n    const animations = [];\n\n    targetNode.dist = 0;\n    queue.enqueue(targetNode);\n\n    while (!queue.isEmpty()) {\n      const currentNode = queue.dequeue();\n      const adj = this.AdjList.get(currentNode); // get neighbors\n      for (let neighbor of adj) {\n        const dist = 1 + currentNode.dist;\n        if (dist < neighbor.dist || neighbor.is(\"Start\")) {\n          if (!withAnimation) neighbor.markSearched2Done();\n          animations.push(neighbor);\n          neighbor.dist = dist;\n          neighbor.predecessor = currentNode;\n          if (neighbor === startNode) {\n            if (!withAnimation) {\n              neighbor.markShortestPath();\n              return [];\n            }\n            return animations;\n          }\n          queue.enqueue(neighbor);\n        }\n      }\n    }\n\n    return animations;\n  }\n\n  /**\n   * Perform Prim's Algorithm on the graph\n   *\n   * @param {*} startNode Reference to start node\n   * @param {*} targetNode Reference to target node\n   * @param {*} withAnimation Boolean indicating if animations are desired\n   */\n  Prims(startNode, targetNode, withAnimation) {\n    if (startNode === null) return [];\n    if (targetNode === null) return [];\n\n    const heap = new MinHeap((node) => node.dist);\n    const mst = {};\n    const animations = [];\n    startNode.dist = 0;\n    heap.push(startNode);\n\n    while (!heap.isEmpty()) {\n      const currentNode = heap.pop();\n\n      const adjacentNodes = this.AdjList.get(currentNode);\n\n      animations.push(currentNode);\n\n      for (let adj of adjacentNodes) {\n        if (adj.dist > adj.getWeight()) {\n          !withAnimation && adj.markSearched2Done();\n          heap.push(adj);\n          adj.dist = adj.getWeight();\n        }\n      }\n\n      mst[currentNode.toString()] = currentNode;\n    }\n\n    if (!withAnimation) targetNode.markShortestPath();\n\n    return withAnimation ? animations : [];\n  }\n\n  /**\n   * Perform kruskal's algorithm\n   */\n  kruskal() {\n    // Heap used to order the edges\n    const heap = new MinHeap((el) => el.w);\n\n    // Disjoint set to keep track of cycles\n    const ds = new DisjointSet(5000);\n    const mst = [];\n    const edges = {};\n    const animations = [];\n\n    // Go thru all edges\n    this.AdjList.forEach((arr, key) => {\n      arr.forEach((adj) => {\n        const edgeId = [key.id, adj.id];\n        edgeId.sort((a, b) => a - b);\n\n        // Add the edge to the heap\n        if (!edges.hasOwnProperty(edgeId.toString())) {\n          edges[edgeId] = true;\n          heap.push({\n            nodes: [key, adj],\n            w: key.getWeight() + adj.getWeight() - 1,\n            i: key.id,\n            j: adj.id,\n          });\n        }\n      });\n    });\n\n    // Go thru the heap contents\n    while (!heap.isEmpty()) {\n      const currentEdge = heap.pop();\n      const hasCycle = ds.hasCycle(currentEdge.i, currentEdge.j);\n\n      // If the edge does not cause a cycle add it to the MST\n      if (!hasCycle) {\n        animations.push(currentEdge.nodes[0]);\n        animations.push(currentEdge.nodes[1]);\n        mst.push(currentEdge);\n      }\n    }\n\n    return animations;\n  }\n\n\n  /**\n   * Perform Bellman Ford's Algorithm on the graph\n   * @param {*} startNode Reference to start node\n   * @param {*} nodeGrid Reference to node Grid\n   * @param {*} withAnimation Boolean indicating if animations are desired \n   */\n  bellmanFord(startNode, nodeGrid, withAnimation) {\n    if (startNode === null) return [];\n    // Initialize startVertex by setting dist = 0\n    startNode.dist = 0;\n\n    // HashMap to store the nodes By their ID\n    const nodes = {};\n\n    // Calculate number of nodes\n    const n = nodeGrid.length * nodeGrid[0].length;\n\n    // Create a HashMap Of Id -> Node Obj\n    for (let id = 1; id <= n; id++) {\n      // get Node Given an Id\n      const node = Node.getNode(id, nodeGrid);\n      nodes[id] = node;\n    }\n\n    // Animate all nodes\n    let animations = [...Object.values(nodes)];\n    animations = animations.filter((node) => !node.is(\"Wall\"));\n\n    // Relax the edges\n    for (let i = 1; i < this.noOfVertices; i++) {\n      // Go thru all edges and relax them\n      this.AdjList.forEach((arr, key) => {\n        arr.forEach((adj) => {\n          if (key.dist > adj.dist + adj.getWeight()) {\n            key.dist = adj.dist + adj.getWeight();\n            key.predecessor = adj;\n          }\n        });\n      });\n    }\n\n    return animations;\n  }\n}\n","export class MinHeap {\n  constructor(selector) {\n    this.items = [];\n    this.selector = selector;\n  }\n\n  peek() {\n    return this.items[0];\n  }\n\n  push(item) {\n    let i = this.items.length;\n    this.items.push(item);\n\n    let parentIndex = Math.floor((i + 1) / 2 - 1);\n\n    if (parentIndex < 0) parentIndex = 0;\n\n    let parentVal = this.selector(this.items[parentIndex]);\n    const pushedVal = this.selector(this.items[i]);\n\n    while (i > 0 && parentVal > pushedVal) {\n      parentIndex = Math.floor((i + 1) / 2 - 1);\n\n      this.swap(i, parentIndex);\n\n      i = parentIndex;\n\n      parentVal = this.selector(\n        this.items[Math.max(Math.floor((i + 1) / 2 - 1), 0)]\n      );\n    }\n  }\n\n  swap(i, j) {\n    let t = this.items[i];\n    this.items[i] = this.items[j];\n    this.items[j] = t;\n  }\n\n  pop() {\n    if (this.items.length <= 1) return this.items.pop(); //If it is the last element pop it\n    const ret = this.items[0]; // What we will return\n    let temp = this.items.pop();\n    this.items[0] = temp; // Place last element in array at front\n\n    let i = 0; // We adjust heap from top to down\n\n    while (true) {\n      let rightChildIndex = (i + 1) * 2;\n      let leftChildIndex = (i + 1) * 2 - 1;\n      let lowest = rightChildIndex;\n\n      if (\n        leftChildIndex >= this.items.length &&\n        rightChildIndex >= this.items.length\n      )\n        break;\n      if (leftChildIndex >= this.items.length) lowest = rightChildIndex;\n      if (rightChildIndex >= this.items.length) lowest = leftChildIndex;\n\n      if (\n        !(leftChildIndex >= this.items.length) &&\n        !(rightChildIndex >= this.items.length)\n      ) {\n        lowest =\n          this.selector(this.items[rightChildIndex]) <\n          this.selector(this.items[leftChildIndex])\n            ? rightChildIndex\n            : leftChildIndex;\n      } // Find the smallest child\n\n      // If the parent is greater than the smallest child: swap\n      if (this.selector(this.items[i]) > this.selector(this.items[lowest])) {\n        this.swap(i, lowest);\n        i = lowest;\n      } else break; // We have finished setting up the heap\n    }\n\n    // Return topmost element\n    return ret;\n  }\n\n  contains(item) {\n    return this.items.includes(item);\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  delete(item) {\n    let i = this.items.indexOf(item);\n    // heapify\n    this.items[i] = this.items.pop();\n    while (true) {\n      let lowest =\n        this.selector(this.items[(i + 1) * 2]) <\n        this.selector(this.items[(i + 1) * 2 - 1])\n          ? (i + 1) * 2\n          : (i + 1) * 2 - 1;\n      if (this.selector(this.items[i]) > this.selector(this.items[lowest])) {\n        let t = this.items[i];\n        this.items[i] = this.items[lowest];\n        this.items[lowest] = t;\n        i = lowest;\n      } else break;\n    }\n  }\n\n  print() {\n    for (let i = 0; i < this.items.length; i++) {\n      console.log(this.items[i]);\n    }\n  }\n\n  heapify(arr) {\n    for (let i = 0; i < arr.length; i++) {\n      this.push(arr[i]);\n    }\n  }\n}","export const DIJKSTRA = \"Dijkstra\"\nexport const ASTAR = \"A*\"\nexport const GREEDY_BFS = \"Greedy Best First Search\"\nexport const BFS = \"Breadth First Search\"\nexport const DFS = \"Depth First Search\"\nexport const PRIMS = \"Prim's Algorithm\"\nexport const DSTAR = \"D*\"\nexport const KRUSKAL = \"Kruskal's Algorithm\"\nexport const FLOYD_WARSHALL = \"Floyd-Warshall\"\nexport const BELLMAN_FORD = \"Bellman-Ford\"\n\nexport const RAND_MAZE = \"Random Maze\"\nexport const RECURSIVE_DIVISON = \"Recursive Division\"\nexport const DRAW_COUNTOUR = \"Contour Walls\"\n\nexport const ADDING_WEIGHT = \"Adding Weight\"\nexport const MOVING_TARGET = \"Moving Target\"\nexport const MOVING_START = \"Moving Start\"\nexport const MOVING_SECOND_TARGET = \"Moving Second Target\"\nexport const SETTING_SECOND_TARGET = \"Moving Second Target\"\nexport const DELETING = \"Deleting\"\nexport const PLACING_WALLS = \"Placing Walls\"\nexport const VISUALIZING = \"Visualizing\"\n\nexport const ALG_TITLE = {}\nALG_TITLE[DIJKSTRA] = \"Dijkstra's Algorithm is a weighted algorithm that guarantees the shortest path\"\nALG_TITLE[ASTAR] = \"A* Algorithm is a weighted algorithm that guarantees the shortest path\"\nALG_TITLE[GREEDY_BFS] = \"Greedy BFS Algorithm is a weighted algorithm that does not guarantee the shortest path\"\nALG_TITLE[FLOYD_WARSHALL] = \"Floyd-Warshall algorithm is a weighted algorithm that guarantees to find the minimum distance between ANY two nodes\"\nALG_TITLE[BFS] = \"BFS is an un-weighted algorithm, it guarantees the shortest path in an unweighted graph but not in a weighted one\"\nALG_TITLE[DFS] = \"DFS is an un-weighted algorithm with the purpose of traversing a graph, shortest path/distance is NOT guaranteed\"\nALG_TITLE[PRIMS] = \"Prim's algorithm is used to find the Minimum Spanning Tree of a weighted Graph, shortest path/distance is NOT guaranteed\"\nALG_TITLE[KRUSKAL] = \"Kruskal's algorithm is used to find the Minimum Spanning Tree of a weighted Graph, shortest path/distance is NOT guaranteed\"\n","// O(V^3)\nexport const floydWarshall = (nodeGrid, startNode) => {\n  const n = nodeGrid.length * nodeGrid[0].length; // number of vertices\n  const mtrx = [];\n  const animations = [];\n  let distance = 1;\n\n  // array to store the path\n  const path = new Array(n);\n\n  // HashMap to store the nodes By their ID\n  const nodes = {};\n\n  let startId = 0;\n  let targetId = 0;\n\n  // For each vertex ID\n  for (let i = 1; i <= n; i++) {\n    // Get node given ID : i\n    const node = getNode(i, nodeGrid);\n\n    // Save it to Hashmap for later use\n    nodes[i] = node;\n\n    path[i] = [];\n\n    path[i][i] = i;\n\n    // Get vertex neighbors\n    const neighbors = node.getNeighbors(nodeGrid);\n\n    // For Each neighbor\n    for (let neighbor of neighbors) {\n      path[i][neighbor.id] = neighbor.id;\n    }\n\n    if (node.is(\"Start\")) startId = node.id;\n    if (node.is(\"Target\")) targetId = node.id;\n    if (!node.is(\"Wall\")) animations.push(node);\n  }\n\n  // Create the mtrx with initial values\n  for (let row = 1; row <= n; row++) {\n    mtrx[row] = [];\n    for (let col = 1; col <= n; col++) {\n      const start = nodes[row];\n      const end = nodes[col];\n\n      if (!path[row][col]) path[row][col] = 0;\n\n      mtrx[row][col] = start.getDistanceTo(end); // Distance from start to end\n    }\n  }\n\n  // Update the mtrx\n  for (let k = 1; k <= n; k++) {\n    for (let i = 1; i <= n; i++) {\n      for (let j = 1; j <= n; j++) {\n        // Keep the code inside here lean so that it remains fast\n\n        // If it is faster via k\n        if (mtrx[i][k] + mtrx[k][j] < mtrx[i][j]) {\n          mtrx[i][j] = mtrx[i][k] + mtrx[k][j];\n          path[i][j] = path[i][k];\n        }\n      }\n    }\n  }\n\n  // Update the distances on the start and target node so that the UI Updates\n  nodes[startId].dist = mtrx[startId][targetId];\n  distance = mtrx[startId][targetId];\n\n  return { mtrx, animations, distance, startId, targetId, path };\n};\n\nfunction getNode(id, nodeGrid) {\n  // O(1)\n  // returns a reference to the node given the id\n  const width = nodeGrid[0].length;\n  const row = Math.floor((id - 1) / width);\n  const col = (id - 1) % width;\n  return nodeGrid[row][col];\n}\n\n// Return array of path given ID: u, v, and path matrix\nexport const getPath = (u, v, path) => {\n  if (path[u][v] === 0) return [];\n  const result = [];\n  while (u !== v) {\n    u = path[u][v];\n    result.push(u);\n  }\n  return result;\n};\n","import { useState, useCallback } from \"react\";\nimport Node from \"../utility/Node\";\n\nconst generateNodeGrid = (numRows, numCols) => {\n  const nodesGrid = [];\n  let id = 1;\n\n  for (let row = 0; row < numRows; row++) {\n    nodesGrid[row] = [];\n    for (let col = 0; col < numCols; col++) {\n      nodesGrid[row][col] = new Node(row, col, id);\n      id++;\n    }\n  }\n\n  return nodesGrid;\n};\n\nconst useNodeGrid = (rows, cols) => {\n  const [numRows, setNumRows] = useState(rows);\n  const [numCols, setNumCols] = useState(cols);\n\n  const nodeGrid = useCallback(generateNodeGrid(numRows, numCols), [\n    numRows,\n    numCols,\n  ]);\n\n  const resetGrid = () => {\n    for (let row in nodeGrid) {\n      for (let cell of nodeGrid[row]) {\n        cell.reset();\n      }\n    }\n  };\n\n  const clearGrid = () => {\n    for (let row in nodeGrid) {\n      for (let cell of nodeGrid[row]) {\n        cell.reset();\n        cell.remove([\"Start\", \"Target\"]);\n      }\n    }\n  };\n\n  const removeVisuals = () => {\n    for (let row in nodeGrid) {\n      for (let node of nodeGrid[row]) {\n        node.removeVisuals();\n      }\n    }\n  };\n\n  const paintInDistance = (dist) => {\n    if (dist === Infinity) return;\n    for (let row in nodeGrid) {\n      for (let node of nodeGrid[row]) {\n        if (node.dist <= dist) {\n          node.markSearched2Done();\n        } else {\n          node.removeClasses();\n        }\n      }\n    }\n  };\n\n  const resetDistance = () => {\n    for (let row in nodeGrid) {\n      for (let node of nodeGrid[row]) {\n        node.dist = Infinity;\n        node.predecessor = null;\n        if (!node.isKeyValue()) {\n          node.removeClasses();\n        }\n      }\n    }\n  };\n\n  return {\n    nodeGrid,\n    resetGrid,\n    removeVisuals,\n    paintInDistance,\n    resetDistance,\n    clearGrid,\n    setNumRows: (numRows) => {\n      clearGrid();\n      setNumRows(numRows);\n    },\n    setNumCols: (numCols) => {\n      clearGrid();\n      setNumCols(numCols);\n    },\n    numRows,\n    numCols,\n  };\n};\n\nexport default useNodeGrid;\n","import React from \"react\";\nimport classes from \"./NavigationItem.module.css\";\n\nconst NavigationItem = ({ children, clicked, style = {} }) => (\n  <div className={classes.NavigationItem}>\n    <button onClick={clicked} className={classes.Btn} style={style}>\n      {children}\n    </button>\n  </div>\n);\nexport default NavigationItem;\n","import React from \"react\";\nimport \"./DropDown.css\";\n\nconst DropDown = ({ children, title }) => {\n  return (\n    <div className=\"dropdown\">\n      <button className=\"dropbtn\">\n        {title}\n      </button>\n      <div className=\"dropdown-content\">\n        {children}\n      </div>\n    </div>\n  );\n};\n\nexport default DropDown;\n","import React from \"react\";\nimport \"./Subnav.css\";\n\nconst Subnav = ({ children, title }) => {\n  return (\n    <div className=\"subnav\">\n      <button className=\"subnavbtn\">{title}</button>\n      <div className=\"subnav-content\">{children}</div>\n    </div>\n  );\n};\n\nexport default Subnav;\n","import React from \"react\";\n\nconst DropItem = ({children, clicked}) => {\nreturn <p onClick={clicked}>{children}</p>;\n};\n\nexport default DropItem;\n","import { useState, useEffect } from \"react\";\n\nlet globalState = {};\nlet listeners = [];\nlet actions = {};\n\nexport const useStore = (shouldListen = true) => {\n  const setState = useState(globalState)[1];\n\n  const dispatch = (actionId, payload) => {\n    const newPortfolio = actions[actionId](globalState, payload);\n    globalState = { ...globalState, ...newPortfolio };\n\n    for (const listener of listeners) {\n      listener(globalState);\n    }\n  };\n\n  useEffect(() => {\n    if (shouldListen) {\n      listeners.push(setState);\n    }\n\n    return () => {\n      if (shouldListen) {\n        listeners = listeners.filter((li) => li !== setState);\n      }\n    };\n  }, [setState, shouldListen]);\n\n  return [globalState, dispatch];\n};\n\nexport const initStore = (userActions, initialState) => {\n  if (initialState) {\n    globalState = { ...globalState, ...initialState };\n  }\n\n  actions = { ...actions, ...userActions };\n};\n","import React from \"react\";\nimport NavigationItem from \"./NavigationItem/NavigationItem\";\nimport * as cts from \"../../../utility\";\nimport DropDown from \"./Dropdown/DropDown\";\nimport Subnav from \"./Subnav/Subnav\";\nimport DropItem from \"./Dropdown/DropItem/DropItem\";\nimport { useStore } from \"../../../hooks-store/store\";\n\nconst NavigationItems = ({\n  reset,\n  executeAlgorithm,\n  algorithm,\n  mazeGen,\n  setSpeed,\n  openDialog,\n  clear,\n  setUserAction,\n  setNumRows,\n}) => {\n  const dispatch = useStore(false)[1];\n  return (\n    <>\n      <NavigationItem clicked={openDialog}>ABOUT</NavigationItem>\n      <Subnav title=\"Algorithms\">\n        <DropDown title={cts.DIJKSTRA}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.DIJKSTRA });\n              dispatch(\"SET_ALGO\", { algo: cts.DIJKSTRA });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem\n            clicked={() => dispatch(\"SET_INFO\", { info: cts.DIJKSTRA })}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.ASTAR}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.ASTAR });\n              dispatch(\"SET_ALGO\", { algo: cts.ASTAR });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem clicked={() => dispatch(\"SET_INFO\", { info: cts.ASTAR })}>\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.GREEDY_BFS}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.GREEDY_BFS });\n              dispatch(\"SET_ALGO\", { algo: cts.GREEDY_BFS });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem\n            clicked={() => dispatch(\"SET_INFO\", { info: cts.GREEDY_BFS })}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.BFS}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_ALGO\", { algo: cts.BFS });\n              dispatch(\"SET_INFO\", { info: cts.BFS });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem clicked={() => dispatch(\"SET_INFO\", { info: cts.BFS })}>\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.DFS}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.DFS });\n              dispatch(\"SET_ALGO\", { algo: cts.DFS });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.DFS });\n            }}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.PRIMS}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.PRIMS });\n              dispatch(\"SET_ALGO\", { algo: cts.PRIMS });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.PRIMS });\n            }}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.KRUSKAL}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.KRUSKAL });\n              dispatch(\"SET_ALGO\", { algo: cts.KRUSKAL });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.KRUSKAL });\n            }}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.FLOYD_WARSHALL}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.FLOYD_WARSHALL });\n              dispatch(\"SET_ALGO\", { algo: cts.FLOYD_WARSHALL });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.KRUSKAL });\n            }}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.DSTAR}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_ALGO\", { algo: cts.DSTAR });\n              dispatch(\"SET_INFO\", { info: cts.DSTAR });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem clicked={() => dispatch(\"SET_INFO\", { info: cts.DSTAR })}>\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.BELLMAN_FORD}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_ALGO\", { algo: cts.BELLMAN_FORD });\n              dispatch(\"SET_INFO\", { info: cts.BELLMAN_FORD });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem clicked={() => dispatch(\"SET_INFO\", { info: cts.BELLMAN_FORD })}>\n            Learn More\n          </DropItem>\n        </DropDown>\n      </Subnav>\n      <Subnav title=\"Maze Generators\">\n        <DropDown title={cts.RAND_MAZE}>\n          <DropItem clicked={() => mazeGen(cts.RAND_MAZE, \"Wall\")}>\n            Generate Walls\n          </DropItem>\n          <DropItem clicked={() => mazeGen(cts.RAND_MAZE, \"Weight\")}>\n            Generate Weights\n          </DropItem>\n          <DropItem\n            clicked={() => dispatch(\"SET_INFO\", { info: cts.RAND_MAZE })}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.RECURSIVE_DIVISON}>\n          <DropItem clicked={() => mazeGen(cts.RECURSIVE_DIVISON, \"Wall\")}>\n            Generate Walls\n          </DropItem>\n          <DropItem clicked={() => mazeGen(cts.RECURSIVE_DIVISON, \"Weight\")}>\n            Generate Weights\n          </DropItem>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.RECURSIVE_DIVISON });\n            }}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.DRAW_COUNTOUR}>\n          <DropItem clicked={() => mazeGen(cts.DRAW_COUNTOUR, \"Wall\")}>\n            Generate Walls\n          </DropItem>\n          <DropItem clicked={() => mazeGen(cts.DRAW_COUNTOUR, \"Weight\")}>\n            Generate Weights\n          </DropItem>\n          <DropItem\n            clicked={() => dispatch(\"SET_INFO\", { info: cts.DRAW_COUNTOUR })}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n      </Subnav>\n      <Subnav title=\"Options\">\n        <DropDown title=\"Draw\">\n          <DropItem clicked={() => setUserAction(cts.DELETING)}>\n            Delete Wall\n          </DropItem>\n          <DropItem clicked={() => setUserAction(cts.PLACING_WALLS)}>\n            Draw Wall\n          </DropItem>\n        </DropDown>\n        <DropDown title=\"Add Weight\">\n          <DropItem clicked={() => setUserAction(cts.ADDING_WEIGHT)}>\n            Add Weight\n          </DropItem>\n          <DropItem clicked={() => setUserAction(cts.PLACING_WALLS)}>\n            Draw Wall\n          </DropItem>\n        </DropDown>\n        <DropDown title=\"Set Grid Size\">\n          <DropItem\n            clicked={() => {\n              setNumRows(10);\n            }}\n          >\n            Small\n          </DropItem>\n          <DropItem\n            clicked={() => {\n              setNumRows(20);\n            }}\n          >\n            Medium\n          </DropItem>\n          <DropItem clicked={() => setNumRows(30)}>\n            Large (Beware of Lag)\n          </DropItem>\n        </DropDown>\n        <DropDown title=\"Set Animation Speed\">\n          <DropItem\n            clicked={() => {\n              setSpeed(100);\n            }}\n          >\n            Slow\n          </DropItem>\n          <DropItem\n            clicked={() => {\n              setSpeed(50);\n            }}\n          >\n            Medium\n          </DropItem>\n          <DropItem clicked={() => setSpeed(10)}>Fast</DropItem>\n        </DropDown>\n      </Subnav>\n\n      {/* <NavigationItem clicked={() => settingSecondTarget(true)}>Add Second Target</NavigationItem> */}\n      <NavigationItem clicked={reset}>Reset</NavigationItem>\n      <NavigationItem clicked={clear}>Clear Visualization</NavigationItem>\n      <NavigationItem clicked={executeAlgorithm} style={{ color: \"red\" }}>\n        Visualize {algorithm}!\n      </NavigationItem>\n    </>\n  );\n};\nexport default NavigationItems;\n","import React from \"react\";\nimport classes from \"./Toolbar.module.css\";\nimport NavigationItems from \"../NavigationItems/NavigationItems\";\n\nconst toolbar = (props) => {\n  return (\n    <header className={classes.Toolbar}>\n        <NavigationItems {...props} />\n    </header>\n  );\n};\nexport default toolbar;\n","import React, { useState } from \"react\";\nimport Cell from \"./Cell/Cell\";\nimport * as util from \"../utility/index\";\nimport \"./Board.css\";\nimport useNodeGrid from \"../hooks/useNodeGrid\";\nimport Navbar from \"./Navigation/Toolbar/Toolbar\";\nimport { useStore } from \"../hooks-store/store\";\nimport { Paper, makeStyles } from \"@material-ui/core\";\nimport { getPath } from \"../utility/Algorithms/floydWarshall\";\nimport Node from \"../utility/Node\";\n\nconst ROWS_INIT = 10;\nconst COLS_INIT = 40;\nlet pathMtrx = null;\n\nconst useStyles = makeStyles({\n  paper: {\n    padding: \"5px\",\n    margin: \"auto\",\n    width: \"1200px\",\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n  },\n});\n\nconst Board = ({ openDialog }) => {\n  const { algorithm } = useStore()[0];\n  const classes = useStyles();\n\n  const {\n    nodeGrid,\n    resetGrid,\n    removeVisuals,\n    resetDistance,\n    setNumRows,\n    setNumCols,\n    numRows,\n    numCols,\n  } = useNodeGrid(ROWS_INIT, COLS_INIT);\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [animating, setIsAnimating] = useState(true);\n  const [isMovingTarget, setIsMovingTarget] = useState(false);\n  const [isMovingSecondTarget, setIsMovingSecondTarget] = useState(false);\n  const [isMovingStart, setIsMovingStart] = useState(false);\n  const [settingSecondTarget, setSettingSecondTarget] = useState(false);\n  const [hasSecondTarget, setHasSecondTarget] = useState(false);\n  const [numTargets, setNumTargets] = useState(1);\n  const [prevAlgorithm, setPrevAlgorithm] = useState();\n  const [userAction, setUserAction] = useState(util.PLACING_WALLS);\n  const [animationSpeed, setAnimationSpeed] = useState(10);\n  const [distance, setDistance] = useState(\"Unkown\");\n  const [matrix, setMatrix] = useState(null);\n\n  const handleKeyNodeMove = (node, type) => {\n    if (type === \"Target\") node.setAsTarget();\n    if (type === \"Start\") node.add(\"Start\");\n    if (prevAlgorithm !== util.FLOYD_WARSHALL) resetDistance();\n\n    const { startNode, targetNode } = util.getKeyNodes(nodeGrid);\n\n    switch (prevAlgorithm) {\n      case util.DIJKSTRA:\n        Dijkstra(false);\n        break;\n      case util.ASTAR:\n        AStar(false);\n        break;\n      case util.GREEDY_BFS:\n        bestFirstSearch(false);\n        break;\n      case util.BFS:\n        BFS(false);\n        break;\n      case util.DFS:\n        DFS(false);\n        break;\n      case util.DSTAR:\n        DStar(false);\n        break;\n      case util.PRIMS:\n        Prims(false);\n        break;\n      case util.FLOYD_WARSHALL:\n        setDistance(matrix[startNode.id][targetNode.id]);\n        drawPath(startNode.id, targetNode.id);\n        break;\n      case util.BELLMAN_FORD:\n        bellmanFord(false);\n        targetNode.markShortestPath();\n        break;\n      default:\n    }\n\n    if (\n      prevAlgorithm !== util.FLOYD_WARSHALL &&\n      prevAlgorithm !== util.BELLMAN_FORD\n    )\n      setDistance(targetNode.dist);\n  };\n\n  const onMouseEnterHandler = (node) => {\n    if (!animating) return;\n    if (settingSecondTarget) {\n      return node.setAsSecondTarget();\n    }\n    if (isMouseDown && isMovingStart && !node.is(\"Target\")) {\n      return handleKeyNodeMove(node, \"Start\");\n    }\n    if (isMouseDown && isMovingTarget && !node.is(\"Start\")) {\n      return handleKeyNodeMove(node, \"Target\");\n    }\n    if (isMouseDown && isMovingSecondTarget) return node.setAsSecondTarget();\n    if (userAction === util.PLACING_WALLS && isMouseDown) {\n      return node.setWall();\n    }\n  };\n\n  const onMouseDownHandler = (node) => {\n    setIsMouseDown(true);\n    if (!animating) return;\n    if (userAction === util.ADDING_WEIGHT)\n      return !node.isKeyValue() && node.add(\"Weight\");\n    if (userAction === util.DELETING) return node.remove([\"Wall\", \"Weight\"]);\n    if (settingSecondTarget) {\n      let num = numTargets;\n      setNumTargets(num + 1);\n      setHasSecondTarget(true);\n      return setSettingSecondTarget(false);\n    }\n    if (!node.isKeyValue()) return node.setWall();\n    if (node.is(\"Start\")) setIsMovingStart(true);\n    if (node.is(\"Target\")) setIsMovingTarget(true);\n    if (node.is(\"SecondaryTarget\")) setIsMovingSecondTarget(true);\n  };\n\n  const onMouseLeaveHandler = (node) => {\n    if (!animating) return;\n    if (isMovingStart) node.removeClass(\"Start\");\n    if (isMovingTarget) node.removeClass(\"Target\");\n  };\n\n  const onMouseUpHandler = () => {\n    // if (!animating) return;\n    setIsMouseDown(false);\n    setIsMovingStart(false);\n    setIsMovingTarget(false);\n    setIsMovingSecondTarget(false);\n  };\n\n  let Grid = nodeGrid.map((row, rowNum) => {\n    return row.map((val, colNum) => {\n      return (\n        <Cell\n          key={val}\n          node={nodeGrid[rowNum][colNum]}\n          mouse={{\n            onMouseEnter: onMouseEnterHandler,\n            onMouseDown: onMouseDownHandler,\n            onMouseUp: onMouseUpHandler,\n            onMouseLeave: onMouseLeaveHandler,\n          }}\n          numRows={numRows}\n          numCols={numCols}\n        />\n      );\n    });\n  });\n\n  const executeAlgorithm = () => {\n    removeVisualization();\n    if (!animating) return;\n    setIsAnimating(false);\n    setPrevAlgorithm(algorithm);\n    setUserAction(util.PLACING_WALLS);\n    resetDistance();\n\n    let animations = [];\n\n    switch (algorithm) {\n      case util.BFS:\n        animations = BFS(true);\n        break;\n      case util.DFS:\n        animations = DFS(true);\n        break;\n      case util.ASTAR:\n        animations = AStar(true);\n        break;\n      case util.DIJKSTRA:\n        animations = Dijkstra(true);\n        break;\n      case util.GREEDY_BFS:\n        animations = bestFirstSearch(true);\n        break;\n      case util.DSTAR:\n        animations = DStar(true);\n        break;\n      case util.PRIMS:\n        animations = Prims(true);\n        break;\n      case util.KRUSKAL:\n        animations = Kruskal();\n        break;\n      case util.FLOYD_WARSHALL:\n        animations = floydWarshall(true);\n        break;\n      case util.BELLMAN_FORD:\n        animations = bellmanFord(true);\n        break;\n      default:\n        animations = BFS(true);\n        break;\n    }\n\n    animate(animations, algorithm);\n  };\n\n  const BFS = (withAnimation) => {\n    const { startNode, graph } = util.generateGraph(nodeGrid);\n    const animations = graph.bfs(startNode, withAnimation);\n    return animations;\n  };\n\n  const DFS = (withAnimation) => {\n    const { startNode, graph } = util.generateGraph(nodeGrid);\n    const animations = graph.dfs(startNode, withAnimation);\n    return animations;\n  };\n\n  const Dijkstra = (withAnimation) => {\n    const { startNode, graph } = util.generateGraph(nodeGrid);\n    const animations = [];\n    graph.dijkstra(startNode, animations, hasSecondTarget, withAnimation);\n    return animations;\n  };\n\n  const AStar = (withAnimation) => {\n    const { startNode, graph, targetNode } = util.generateGraph(nodeGrid);\n    const animations = graph.aStar(startNode, targetNode, withAnimation);\n    return animations;\n  };\n\n  const DStar = (withAnimation) => {\n    const { startNode, graph, targetNode } = util.generateGraph(nodeGrid);\n    const animations = graph.dStar(startNode, targetNode, withAnimation);\n    return animations;\n  };\n\n  const floydWarshall = () => {\n    const { animations, distance, mtrx, path } = util.floydWarshall(nodeGrid);\n    pathMtrx = path;\n    setDistance(distance);\n    setMatrix(mtrx);\n\n    return animations;\n  };\n\n  const bestFirstSearch = (withAnimation) => {\n    const { startNode, graph, targetNode } = util.generateGraph(nodeGrid);\n    const animations = graph.bestFirstSearch(\n      startNode,\n      targetNode,\n      withAnimation\n    );\n    return animations;\n  };\n\n  const Prims = (withAnimation) => {\n    const { startNode, graph, targetNode } = util.generateGraph(nodeGrid);\n    const animations = graph.Prims(startNode, targetNode, withAnimation);\n    return animations;\n  };\n\n  const Kruskal = () => {\n    const { graph } = util.generateGraph(nodeGrid);\n    const animations = graph.kruskal();\n    return animations;\n  };\n\n  const bellmanFord = (withAnimation) => {\n    const { graph, startNode, targetNode } = util.generateGraph(nodeGrid);\n    const animations = graph.bellmanFord(startNode, nodeGrid, withAnimation);\n    setDistance(targetNode.dist);\n    return animations;\n  };\n\n  const drawPath = (startId, targetId) => {\n    const finalPath = getPath(startId, targetId, pathMtrx);\n    let prevNode = null;\n\n    for (let nodeId of finalPath) {\n      const node = Node.getNode(nodeId, nodeGrid);\n      node.predecessor = prevNode;\n      prevNode = node;\n    }\n    prevNode && prevNode.markShortestPath();\n  };\n\n  const clear = () => {\n    if (!animating) return;\n    setHasSecondTarget(false);\n    setPrevAlgorithm(null);\n    setDistance(\"Unkown\");\n    setMatrix(null);\n    pathMtrx = null;\n    resetGrid();\n  };\n\n  const removeVisualization = () => {\n    if (!animating) return;\n    setPrevAlgorithm(null);\n    setDistance(\"Unkown\");\n    removeVisuals();\n  };\n\n  const generateMaze = (type, obj) => {\n    if (!animating) return;\n    clear();\n\n    switch (type) {\n      case util.RECURSIVE_DIVISON:\n        util.recursiveDivision(nodeGrid, obj);\n        break;\n      case util.DRAW_COUNTOUR:\n        util.drawContourWalls(nodeGrid, obj);\n        break;\n      default:\n        util.randomMaze(nodeGrid, obj);\n        break;\n    }\n  };\n\n  const animate = (animations, algorithm) => {\n    if (animations.length <= 0) return setIsAnimating(true);\n\n    let count = 0;\n\n    const intervalId = setInterval(() => {\n      const node = animations[count];\n\n      !node.is(\"Weight\") ? node.markSearched() : node.markSearched2Done();\n\n      if (node.is(\"Target\") || node.is(\"SecondaryTarget\")) {\n        algorithm !== util.FLOYD_WARSHALL && setDistance(node.dist);\n        node.markShortestPath();\n      }\n\n      if (node.is(\"Start\") && algorithm === util.DSTAR) {\n        node.markShortestPath();\n        setDistance(node.dist);\n      }\n\n      count++;\n\n      if (count >= animations.length) {\n        setIsAnimating(true);\n        clearInterval(intervalId);\n        if (algorithm === util.FLOYD_WARSHALL) {\n          const { startNode, targetNode } = util.getKeyNodes(nodeGrid);\n          drawPath(startNode.id, targetNode.id);\n        }\n      }\n    }, animationSpeed);\n  };\n\n  return (\n    <div className=\"text-center\">\n      <Navbar\n        openDialog={openDialog}\n        reset={clear}\n        algorithm={algorithm}\n        executeAlgorithm={executeAlgorithm}\n        clear={removeVisualization}\n        mazeGen={generateMaze}\n        settingSecondTarget={setSettingSecondTarget}\n        setUserAction={setUserAction}\n        setNumRows={setNumRows}\n        setNumCols={setNumCols}\n        setSpeed={setAnimationSpeed}\n      />\n      <br />\n      <Paper className={classes.paper}>\n        <h2>\n          Click on a Cell to add Walls! You can also drag the target/start!\n        </h2>\n        <h3 style={{ color: \"red\" }}>Distance: {distance} </h3>\n        <p>{util.ALG_TITLE[algorithm]}</p>\n      </Paper>\n      <div\n        className=\"Board\"\n        style={{\n          gridTemplateRows: `repeat(${numRows}, 1fr)`,\n          gridTemplateColumns: `repeat(${numCols}, 1fr)`,\n        }}\n      >\n        {Grid}\n      </div>\n    </div>\n  );\n};\n\nconst compare = (prevProps, nextProps) => {\n  return true;\n};\n\nexport default React.memo(Board, compare);\n","const WALL_PROBABILITY = 0.3\n\nexport const randomMaze = (board, type) => {\n  for (let row in board) {\n    for (let col in board[row]) {\n      const node = board[row][col]\n      if(!node.isKeyValue()) Math.random() <= WALL_PROBABILITY && node.add([type]);\n    }\n  }\n};\n","import React from \"react\";\nimport \"./Backdrop.css\";\n\nconst backdrop = (props) => {\n  const cssClasses = [\n    \"Backdrop\",\n    props.show ? \"BackdropOpen\" : \"BackdropClosed\",\n  ];\n  return <div className={cssClasses.join(\" \")}></div>;\n};\n\nexport default backdrop;\n","import React from \"react\";\nimport {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogContentText,\n  DialogTitle,\n} from \"@material-ui/core\";\nimport PropTypes from \"prop-types\";\nimport Backdrop from \"../Backdrop/Backdrop\";\n\nexport const CustomDialog = ({\n  isOpen,\n  handleClose,\n  title,\n  subtitle,\n  children,\n  howToPlay,\n}) => {\n  return (\n    <>\n      <Dialog\n        fullWidth\n        maxWidth=\"md\"\n        open={isOpen}\n        onClose={handleClose}\n        aria-labelledby=\"max-width-dialog-title\"\n      >\n        <DialogTitle id=\"max-width-dialog-title\">{title}</DialogTitle>\n        <DialogContent>\n          <DialogContentText>{subtitle}</DialogContentText>\n          {children}\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={handleClose} color=\"secondary\">\n            Close\n          </Button>\n        </DialogActions>\n      </Dialog>\n      <Backdrop show={isOpen} />\n    </>\n  );\n};\n\nCustomDialog.propTypes = {\n  isOpen: PropTypes.bool.isRequired,\n  handleClose: PropTypes.func.isRequired,\n  title: PropTypes.string.isRequired,\n  subtitle: PropTypes.string,\n  children: PropTypes.element.isRequired,\n};\n","import React from \"react\";\nimport classes from \"./Footer.module.css\";\nimport github from \"../../resources/logos/github.png\";\n\nconst logoWidth = 40;\nconst Footer = (props) => {\n  return (\n    <>\n      <div className={classes.Footer}>\n        <div className={classes.IconContainer}>\n          <ul className={classes.Icons}>\n            <li className=\"link d-inline-block\" style={{ listStyle: \"none\" }}>\n              <a\n                href=\"https://github.com/luisalfonsopreciado/Graph-Algorithms-Visualization\"\n                rel=\"noopener noreferrer\"\n                className=\"LinkU\"\n                target=\"_blank\"\n              >\n                <img src={github} width={logoWidth} alt=\"github\" />\n              </a>\n            </li>\n          </ul>\n        </div>\n      </div>\n    </>\n  );\n};\nexport default Footer;\n","import { initStore } from \"./store\";\nimport * as cts from \"../utility/constants\";\n\nconst configureStore = () => {\n  const actions = {\n    SET_ALGO: async (state, action) => {\n      state.algorithm = action.algo;\n      return { ...state, algorithm: action.algo };\n    },\n    SET_INFO: async (state, action) => {\n      state.info = action.info;\n      return { ...state, info: action.info };\n    },\n  };\n  initStore(actions, { algorithm: cts.DIJKSTRA, info: cts.DIJKSTRA });\n};\n\nexport default configureStore;\n","import React, { useState, useEffect } from \"react\";\nimport Board from \"./components/Board\";\nimport { CustomDialog } from \"./components/UI/CustomDialog/CustomDialog\";\nimport Paper from \"@material-ui/core/Paper\";\nimport styles from \"./App.module.css\";\nimport Footer from \"./components/Footer/Footer\";\nimport configureAlgorithmStore from \"./hooks-store/algorithm\";\nimport { useStore } from \"./hooks-store/store\";\nimport marked from \"marked\";\nimport { makeStyles } from \"@material-ui/core\";\n\nconfigureAlgorithmStore();\n\nconst useStyles = makeStyles({\n  paper: {\n    padding: \"5px\",\n    margin: \"auto\",\n    width: \"1200px\",\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n  },\n  padding: {\n    padding: \"5px\",\n  },\n});\n\nfunction App() {\n  const [isOpen, setIsOpen] = useState(true);\n  const [markdown, setMarkdown] = useState(null);\n  const [state] = useStore();\n  const classes = useStyles();\n\n  useEffect(() => {\n    const getMarkdown = async () => {\n      const info = await import(`./info/${state.info}.md`);\n      const res = await fetch(info.default);\n      const text = await res.text();\n      const markdown = marked(text);\n      setMarkdown(markdown);\n    };\n    getMarkdown();\n  }, [state.info]);\n\n  useEffect(() => {\n    handleDialogOpen();\n  }, []);\n\n  const handleDialogOpen = () => {\n    setIsOpen(true);\n  };\n\n  const handleDialogClose = () => {\n    setIsOpen(false);\n  };\n\n  return (\n    <>\n      <div className={styles.App}>\n        <Board openDialog={handleDialogOpen} />\n        <Paper className={classes.paper} elevation={10}>\n          <div dangerouslySetInnerHTML={{ __html: markdown }} />\n        </Paper>\n      </div>\n\n      <CustomDialog\n        title=\"\"\n        isOpen={isOpen}\n        handleClose={handleDialogClose}\n        className={styles.customDialog}\n      >\n        <h1>Welcome to The Graph Algorithms Visualizer!</h1>\n        <br />\n        <h4>\n          This Project Helps CS Enthusiasts visualize graph\n          traversal/path-finding algorithms. To get Started, click on an\n          algorithm located on the header and press Visualize!.\n        </h4>\n        <h4>For a better Experience, set your browser to full width</h4>\n      </CustomDialog>\n\n      <Footer />\n    </>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\nconsole.log(process.env.PUBLIC_URL);\n"],"sourceRoot":""}