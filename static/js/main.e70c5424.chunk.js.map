{"version":3,"sources":["components/Footer/Footer.module.css","components/Navigation/NavigationItems/NavigationItem/NavigationItem.module.css","App.module.css","components/Navigation/Toolbar/Toolbar.module.css","resources/logos/github.png","info lazy /^/.//.*/.md$/ groupOptions: {} namespace object","utility/constants.js","components/Cell/Cell.js","utility/MazeGenerators/Contour.js","utility/MazeGenerators/RecursiveDivision.js","utility/MazeGenerators/PrimsAlgorithm.js","utility/generateGraph.js","utility/DS/Queue.js","utility/DS/DisjointSet.js","utility/Node.js","utility/AlgExecInfo.js","utility/DS/Graph.js","utility/DS/MinHeap.js","utility/Algorithms/floydWarshall.js","hooks/useNodeGrid.js","components/Navigation/NavigationItems/NavigationItem/NavigationItem.js","components/Navigation/NavigationItems/Dropdown/DropDown.js","components/Navigation/NavigationItems/Subnav/Subnav.js","components/Navigation/NavigationItems/Dropdown/DropItem/DropItem.js","hooks-store/store.js","components/Navigation/NavigationItems/NavigationItems.js","components/Navigation/Toolbar/Toolbar.js","components/Board.js","utility/MazeGenerators/Random.js","components/UI/Backdrop/Backdrop.js","components/UI/CustomDialog/CustomDialog.js","components/Footer/Footer.js","hooks-store/algorithm.js","App.js","index.js"],"names":["module","exports","map","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","then","e","Error","code","ids","id","t","keys","Object","GREEDY_BFS","BFS","DFS","PRIMS","KRUSKAL","PRIMS_ALGO","PRIMS_ALGO_531","WALL","WEIGHT","START","TARGET","N_WEIGHT","ALG_TITLE","UNK","randBetween","min","max","Math","floor","random","Cell","node","mouse","numRows","numCols","classes","useEffect","setClasses","row","col","push","cts","className","join","onMouseDown","onMouseEnter","onMouseLeave","onMouseUp","drawContourWalls","grid","type","i","isKeyValue","add","length","j","divide","width","height","orientation","prohibited","isCutHorizontal","whereCol","whereRow","passCol","passRow","drawWall","updateProhibitedCells","newWidth","newHeight","newOrientation","chooseOrientation","startRow","startCol","cell","horizontal","lookupTable531","isRoom","isWall","isPillar","Wall","wallNode","graph","set","matches","0","1","2","3","this","locations","colorMatch","getColorCode","AdjList","get","out","isRoom531","isWall531","colorCode","isPillar531","lookupTable","m","generateNodeGrid","nodesGrid","Graph","document","getElementsByClassName","addVertex","getKeyNodes","startNode","targetNode","currentNode","is","remove","generateGraph","neighbors","getNeighbors","addEdge","dist","Queue","items","element","isEmpty","shift","str","DisjointSet","setParent","child","parent","weight","getWeight","num","findParent","hasCycle","v1","v2","p1","p2","union","Array","fill","parent1","parent2","Node","predecessor","Infinity","g","h","f","cellNotInGraph","end","isNeighbor","s","getElementById","classList","markShortestPath","forEach","item","name","contains","getNode","nodeGrid","AlgExecInfo","animations","distance","algorithm","withAnimation","negativeCycle","kwargs","noOfVertices","Map","v","w","get_keys","get_values","conc","console","log","startingNode","visited","q","enqueue","minDistance","size","getQueueElement","dequeue","get_List","n","neigh","markSearched2Done","DFSUtil","vert","output","neighbor","heap","MinHeap","pop","adjacentNode","tentativeDistance","manhattanDistance","currentdist","adj","tentativeGScore","abs","greedyHeuristic","a","d","sqrt","pow","queue","mst","adjacentNodes","toString","el","ds","edges","arr","key","edgeId","sort","b","hasOwnProperty","nodes","currentEdge","values","filter","containsNegativeCycle","curr","selector","parentIndex","getParentIndex","parentVal","pushedVal","swap","index","ret","temp","rightChildIndex","getRightIndex","leftChildIndex","getLeftIndex","lowest","leftIndexOB","rightIndexOB","includes","indexOf","useNodeGrid","rows","cols","useState","setNumRows","setNumCols","useCallback","clearGrid","reset","resetGrid","removeVisuals","paintInDistance","removeClasses","resetDistance","NavigationItem","children","clicked","style","onClick","Btn","DropDown","title","Subnav","DropItem","globalState","listeners","actions","useStore","shouldListen","setState","dispatch","actionId","payload","newPortfolio","listener","li","NavigationItems","executeAlgorithm","mazeGen","setSpeed","openDialog","clear","setUserAction","info","algo","color","toolbar","props","Toolbar","pathMtrx","useStyles","makeStyles","paper","padding","margin","marginTop","marginBottom","Board","isMouseDown","setIsMouseDown","animating","setIsAnimating","isMovingTarget","setIsMovingTarget","isMovingStart","setIsMovingStart","settingSecondTarget","setSettingSecondTarget","prevAlgorithm","setPrevAlgorithm","userAction","animationSpeed","setAnimationSpeed","util","setDistance","matrix","setMatrix","handleKeyNodeMove","setAsTarget","Dijkstra","AStar","bestFirstSearch","DStar","Prims","drawPath","bellmanFord","onMouseEnterHandler","setAsSecondTarget","setWall","onMouseDownHandler","onMouseLeaveHandler","removeClass","onMouseUpHandler","Grid","rowNum","val","colNum","bfs","dfs","dijkstra","aStar","dStar","floydWarshall","algExecInfo","mtrx","path","startId","targetId","start","getDistanceTo","k","Kruskal","kruskal","bidirectionalBFS","finalPath","u","result","getPath","prevNode","nodeId","removeVisualization","animate","count","targetNodeRef","intervalId","setInterval","markSearched","clearInterval","obj","prohibitedCells","closedWalls","openWalls","rooms","pillars","wallList","isStartNodeRoom","isTargetNodeRoom","neitherRooms","randIndex","currentRandomWall","splice","roomsAdjacentToCurrWall","numNotInPath","unvisitedRoom","wall","st","nodesConsideredAsWalls","newWall","cellInWall","addedWalls","board","Paper","gridTemplateRows","gridTemplateColumns","backdrop","cssClasses","show","CustomDialog","isOpen","handleClose","subtitle","howToPlay","Dialog","fullWidth","maxWidth","open","onClose","aria-labelledby","DialogTitle","DialogContent","DialogContentText","DialogActions","Button","Footer","IconContainer","Icons","listStyle","href","rel","target","src","github","alt","configureStore","userActions","initialState","SET_ALGO","state","action","SET_INFO","configureAlgorithmStore","App","setIsOpen","markdown","setMarkdown","fetch","default","res","text","marked","getMarkdown","handleDialogOpen","styles","elevation","dangerouslySetInnerHTML","__html","customDialog","ReactDOM","render","StrictMode"],"mappings":"wHACAA,EAAOC,QAAU,CAAC,OAAS,uBAAuB,MAAQ,sBAAsB,cAAgB,8BAA8B,YAAc,8B,mBCA5ID,EAAOC,QAAU,CAAC,eAAiB,uCAAuC,IAAM,4BAA4B,OAAS,+BAA+B,yBAAyB,iD,mBCA7KD,EAAOC,QAAU,CAAC,IAAM,iBAAiB,UAAY,yB,mBCArDD,EAAOC,QAAU,CAAC,QAAU,2B,iBCD5BD,EAAOC,QAAU,syP,gKCAjB,IAAIC,EAAM,CACT,UAAW,CACV,GACA,GAED,oBAAqB,CACpB,GACA,GAED,yBAA0B,CACzB,GACA,GAED,4BAA6B,CAC5B,GACA,GAED,qBAAsB,CACrB,GACA,GAED,UAAW,CACV,GACA,GAED,0BAA2B,CAC1B,GACA,GAED,gBAAiB,CAChB,GACA,IAED,sBAAuB,CACtB,GACA,IAED,gCAAiC,CAChC,GACA,IAED,2BAA4B,CAC3B,GACA,IAED,wBAAyB,CACxB,GACA,IAED,sBAAuB,CACtB,GACA,IAED,mBAAoB,CACnB,GACA,IAED,0BAA2B,CAC1B,GACA,KAGF,SAASC,EAAoBC,GAC5B,IAAIC,EAAoBC,EAAEJ,EAAKE,GAC9B,OAAOG,QAAQC,UAAUC,MAAK,WAC7B,IAAIC,EAAI,IAAIC,MAAM,uBAAyBP,EAAM,KAEjD,MADAM,EAAEE,KAAO,mBACHF,KAIR,IAAIG,EAAMX,EAAIE,GAAMU,EAAKD,EAAI,GAC7B,OAAOR,EAAoBK,EAAEG,EAAI,IAAIJ,MAAK,WACzC,OAAOJ,EAAoBU,EAAED,EAAI,MAGnCX,EAAoBa,KAAO,WAC1B,OAAOC,OAAOD,KAAKd,IAEpBC,EAAoBW,GAAK,GACzBd,EAAOC,QAAUE,G,uIC7EJe,EAAa,2BACbC,EAAM,uBACNC,EAAM,qBACNC,EAAQ,mBAERC,EAAU,sBASVC,EAAa,wBACbC,EAAiB,gCAejBC,EAAO,OACPC,EAAS,SACTC,EAAQ,QACRC,EAAS,SACTC,EAAW,iBAQXC,EAAY,CACzBA,SAAsB,iFACtBA,KAAmB,yEACnBA,2BAAwB,yFACxBA,iBAA4B,sHAC5BA,uBAAiB,oHACjBA,qBAAiB,mHACjBA,mBAAmB,2HACnBA,sBAAqB,+HAKRC,EAAM,UAQNC,EAAc,SAACC,EAAKC,GAE7B,OAAOC,KAAKC,MAAMD,KAAKE,UAAYH,EAAMD,EAAM,GAAKA,IC/BzCK,G,MAjCF,SAAC,GAAuC,IAArCC,EAAoC,EAApCA,KAAMC,EAA8B,EAA9BA,MAAOC,EAAuB,EAAvBA,QAASC,EAAc,EAAdA,QAChCC,EAAU,CD2BI,QCTlB,OAfAC,qBAAU,kBAAML,EAAKM,eAAc,CAACN,IAGlCA,EAAKO,MAAQX,KAAKC,MAAMK,EAAU,IAClCF,EAAKQ,MAAQZ,KAAKC,MAAiB,EAAVM,EAAe,IAExCC,EAAQK,KAAKC,GAGbV,EAAKO,MAAQX,KAAKC,MAAMK,EAAU,IAClCF,EAAKQ,MAAQZ,KAAKC,MAAiB,EAAVM,EAAe,IAExCC,EAAQK,KAAKC,GAIb,yBACEC,UAAWP,EAAQQ,KAAK,KACxBrC,GAAE,UAAKyB,EAAKO,IAAV,YAAiBP,EAAKQ,KACxBK,YAAa,kBAAMZ,EAAMY,YAAYb,IACrCc,aAAc,kBAAMb,EAAMa,aAAad,IACvCe,aAAc,kBAAMd,EAAMc,aAAaf,IACvCgB,UAAW,kBAAMf,EAAMe,UAAUhB,KAxB1B,QCNAiB,EAAmB,SAACC,EAAMC,GACrC,IAAK,IAAIC,KAAKF,EACPA,EAAKE,GAAG,GAAGC,cACdH,EAAKE,GAAG,GAAGE,IAAIH,GAGZD,EAAKE,GAAGF,EAAKE,GAAGG,OAAS,GAAGF,cAC/BH,EAAKE,GAAGF,EAAKE,GAAGG,OAAS,GAAGD,IAAIH,GAIpC,IAAK,IAAIK,KAAKN,EAAK,GACZA,EAAK,GAAGM,GAAGH,cACdH,EAAK,GAAGM,GAAGF,IAAIH,GAGZD,EAAKA,EAAKK,OAAS,GAAGC,GAAGH,cAC5BH,EAAKA,EAAKK,OAAS,GAAGC,GAAGF,IAAIH,IC2B7BM,EAAS,SAATA,EACJlB,EACAC,EACAkB,EACAC,EACAC,EACAC,EACAX,EACAC,GAEA,KAAIO,GAAS,GAAKC,GAAU,GAA5B,CAGA,IAAMG,EHDkB,eGCAF,EAGpBG,EAAWvB,GAAOsB,EAAkB,EAAIrC,EAAY,EAAGiC,EAAQ,IAC/DM,EAAWzB,GAAOuB,EAAkBrC,EAAY,EAAGkC,EAAS,GAAK,GAG/DM,EAAUF,GAAYD,EAAkBrC,EAAY,EAAGiC,EAAQ,GAAK,GAEpEQ,EAAUF,GAAYF,EAAkB,EAAIrC,EAAY,EAAGkC,EAAS,IAM1EQ,EAASH,EAAUD,EAAUD,EAHdA,EAAkBJ,EAAQC,EAGaT,EAAMC,GAC5DiB,EAAsBF,EAASD,EAASH,EAAiBD,GAGzD,IAAIQ,EAAWP,EAAkBJ,EAAQK,EAAWvB,EAChD8B,EAAYR,EAAkBE,EAAWzB,EAAMoB,EAC/CY,EAAiBC,EAAkBH,EAAUC,GAEjDb,EAAOlB,EAAKC,EAAK6B,EAAUC,EAAWC,EAAgBV,EAAYX,EAAMC,GAUxEM,EANaK,EAAkBE,EAAW,EAAIzB,EADjCuB,EAAkBtB,EAAMuB,EAAW,EAGhDM,EAAWP,EAAkBJ,EAAQlB,EAAMkB,EAAQK,EAAW,EAC9DO,EAAYR,EAAkBvB,EAAMoB,EAASK,EAAW,EAAIL,EAC5DY,EAAiBC,EAAkBH,EAAUC,GAQ3CT,EACAX,EACAC,KAaEgB,EAAW,SAACM,EAAUC,EAAUZ,EAAiBP,EAAQL,EAAMC,GACnE,IAAK,IAAIC,EAAI,EAAGA,EAAIG,EAAQH,IAAK,CAC/B,IACMZ,EAAMkC,GAAYZ,EAAkBV,EAAI,GAExCuB,EAAOzB,EAHDuB,GAAYX,EAAkB,EAAIV,IAGvBZ,GAClBmC,EAAKtB,cAAcsB,EAAKrB,IAAI,CAACH,MAWhCqB,EAAoB,SAACd,EAAOC,GAChC,OAAID,EAAQC,EHzEY,aACF,YG4ElBS,EAAwB,SAAC7B,EAAKC,EAAKoC,EAAYf,GACnDA,EAAWpB,KAAK,CAACF,EAAKC,IACjBoC,GAIHf,EAAWpB,KAAK,CAACF,EAAM,EAAGC,IAC1BqB,EAAWpB,KAAK,CAACF,EAAM,EAAGC,MAJ1BqB,EAAWpB,KAAK,CAACF,EAAKC,EAAM,IAC5BqB,EAAWpB,KAAK,CAACF,EAAKC,EAAM,M,gBC/H1BqC,EAAiB,CACrB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAChB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAChB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAChB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAChB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAChB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,IA6IZC,EAAS,SAACvC,EAAKC,GACnB,OAAOD,EAAM,IAAM,GAAKC,EAAM,IAAM,GAQhCuC,EAAS,SAACxC,EAAKC,GACnB,OAAID,EAAM,IAAM,EACPC,EAAM,IAAM,EAEdA,EAAM,IAAM,GAQfwC,EAAW,SAACzC,EAAKC,GACrB,OAAOD,EAAM,IAAM,GAAKC,EAAM,IAAM,GAGhCyC,E,WAcJ,WAAYC,EAAUC,EAAOC,GAAM,yBAbnCC,QAAU,CACRC,EA/Je,EAgKfC,EAjKgB,EAkKhBC,EAnKiB,EAoKjBC,EArKc,GA+KdC,KAAKC,UAAY,GACjB,IAAMC,EAAaF,KAAKL,QACtBQ,EAAaX,EAAS3C,IAAK2C,EAAS1C,IAAKqC,IAE3Ca,KAAKC,UAAUT,GAAYA,EAC3BE,EAAIF,IAAY,EANgB,oBAQfC,EAAMW,QAAQC,IAAIb,IARH,IAQhC,2BAA8C,CAAC,IAAtClD,EAAqC,QACpC6D,EAAa7D,EAAKO,IAAKP,EAAKQ,IAAKqC,KAC/Be,IACRF,KAAKC,UAAU3D,GAAQA,EACvBoD,EAAIpD,IAAQ,IAZgB,+B,uDAmBhC,IADA,IAAIgE,EAAM,GACV,MAAqBtF,OAAOD,KAAKiF,KAAKC,WAAtC,eAAkD,CAChDK,GADe,KAGjB,MAAO,IAAMA,EAAM,Q,KA4IjBC,EAAY,SAAC1D,EAAKC,GACtB,OA7UY,IA6ULqD,EAAatD,EAAKC,EAAKqC,IAG1BqB,EAAY,SAAC3D,EAAKC,GACtB,IAAM2D,EAAYN,EAAatD,EAAKC,EAAKqC,GACzC,OApVkB,IAqVhBsB,GAtViB,IAuVjBA,GArVe,IAsVfA,GAzVc,IA0VdA,GAIEC,EAAc,SAAC7D,EAAKC,GACxB,OAAO,GAGHqD,EAAe,SAACtD,EAAKC,EAAK6D,GAC9B,IAAMC,EAAID,EAAY,GAAG9C,OAAS,EAGlC,OADoB8C,EAAY9D,GADtB8D,EAAY9C,OAAS,IACUf,EAAM8D,IClXpCC,EAAmB,SAACrD,GAC/B,IAAMsD,EAAY,GACZrB,EAAQ,IAAIsB,EAPDC,SAASC,uBL4BR,QK5ByCpD,OAC1CmD,SAASC,uBAAuBjE,GAAUa,QAQ3D,IAAK,IAAIhB,KAAOW,EAEd,IAAK,IAAIV,KADTgE,EAAUjE,GAAO,GACDW,EAAKX,GACnB4C,EAAMyB,UAAU1D,EAAKX,GAAKC,IAG9B,OAAO2C,GAGI0B,EAAc,SAACL,GAI1B,IAHA,IAAIM,EAAY,KACZC,EAAa,KAERxE,EAAM,EAAGA,EAAMiE,EAAUjD,OAAQhB,IACxC,IAAK,IAAIC,EAAM,EAAGA,EAAMgE,EAAUjE,GAAKgB,OAAQf,IAAO,CACpD,IAAMwE,EAAcR,EAAUjE,GAAKC,GAC/BwE,EAAYC,GLSO,kBKRrBD,EAAYE,OAAO,CLQE,iBKPrBF,EAAY1D,ILUS,kBKRnB0D,EAAYC,GAAGvE,KAAYoE,EAAYE,GACvCA,EAAYC,GAAGvE,KAAaqE,EAAaC,GAGjD,MAAO,CAAEF,YAAWC,eAGTI,EAAgB,SAACX,GAM5B,IALA,IAAIM,EAAY,KACZC,EAAa,KAEX5B,EAAQoB,EAAiBC,GAEtBjE,EAAM,EAAGA,EAAMiE,EAAUjD,OAAQhB,IACxC,IAAK,IAAIC,EAAM,EAAGA,EAAMgE,EAAUjE,GAAKgB,OAAQf,IAAO,CACpD,IAAMwE,EAAcR,EAAUjE,GAAKC,GAEnC,IAAKwE,EAAYC,GAAGvE,GAAW,CACzBsE,EAAYC,GAAGvE,KAAYoE,EAAYE,GACvCA,EAAYC,GAAGvE,KAAaqE,EAAaC,GAC7C,IAAMI,EAAYJ,EAAYK,aAAab,GAE3C,IAAK,IAAIpD,KAAKgE,EACZjC,EAAMmC,QAAQN,EAAaI,EAAUhE,KAM7C,OADI0D,IAAWA,EAAUS,KAAO,GACzB,CAAEpC,QAAO2B,YAAWC,e,QC9DhBS,EAAb,WACE,aAAe,oBACb9B,KAAK+B,MAAQ,GAFjB,oDAKUC,GACNhC,KAAK+B,MAAMhF,KAAKiF,KANpB,gCAUI,OAAIhC,KAAKiC,UAAkB,YACpBjC,KAAK+B,MAAMG,UAXtB,8BAeI,OAAIlC,KAAKiC,UAAkB,uBACpBjC,KAAK+B,MAAM,KAhBtB,gCAoBI,OAA6B,IAAtB/B,KAAK+B,MAAMlE,SApBtB,mCAyBI,IADA,IAAIsE,EAAM,GACDzE,EAAI,EAAGA,EAAIsC,KAAK+B,MAAMlE,OAAQH,IAAKyE,GAAOnC,KAAK+B,MAAMrE,GAAK,IACnE,OAAOyE,IA1BX,6BA8BI,OAAOnC,KAAK+B,MAAMlE,WA9BtB,KCWauE,EAAb,WACE,WAAYvE,GAAS,IAAD,gCAIpBwE,UAAY,SAACC,EAAOC,GAClB,IAAMC,EAAS,EAAKC,UAAUH,GAC9B,EAAKP,MAAMO,GAASC,EACpB,EAAKR,MAAMQ,IAAWC,GAPJ,KAUpBC,UAAY,SAACC,GAAD,OAAS,EAAKX,MAAMW,IAVZ,KAYpBC,WAAa,SAACD,GACZ,OAAI,EAAKX,MAAMW,GAAO,EAAUA,EACzB,EAAKC,WAAW,EAAKZ,MAAMW,KAdhB,KAmBpBE,SAAW,SAACC,EAAIC,GACd,IAAMC,EAAK,EAAKJ,WAAWE,GACrBG,EAAK,EAAKL,WAAWG,GAC3B,OAAIC,IAAOC,GAAMD,EAAK,IACtB,EAAKE,MAAMF,EAAIC,IACR,IAvBPhD,KAAK+B,MAAQ,IAAImB,MAAMrF,GAAQsF,MAAM,GAFzC,kDA8BQC,EAASC,GACIrD,KAAKyC,UAAUW,IACfpD,KAAKyC,UAAUY,GAE5BrD,KAAKqC,UAAUgB,EAASD,GACxBpD,KAAKqC,UAAUe,EAASC,OAnChC,KCNqBC,E,WAOnB,WAAYzG,EAAKC,EAAKjC,GAAK,oBACzBmF,KAAKnD,IAAMA,EACXmD,KAAKlD,IAAMA,EACXkD,KAAKnF,GAAKA,EACVmF,KAAKuD,YAAc,KACnBvD,KAAK6B,KAAO2B,IACZxD,KAAKyD,EAAI,EACTzD,KAAK0D,EAAI,KACT1D,KAAK2D,EAAIH,I,yDAQEhG,GACX,IAAMoG,EAAiB,SAAC/G,EAAKC,GAC3B,OAAOU,EAAKX,GAAKC,GAAKyE,GAAGvE,IAG3B,GAAIgD,KAAKuB,GAAGvE,GAAW,MAAO,GAC9B,IAAI0E,EAAY,GAsBhB,OApBI1B,KAAKnD,IAAM,IAAM+G,EAAe5D,KAAKnD,IAAM,EAAGmD,KAAKlD,MAErD4E,EAAU3E,KAAKS,EAAKwC,KAAKnD,IAAM,GAAGmD,KAAKlD,MAErCkD,KAAKlD,IAAM,IAAM8G,EAAe5D,KAAKnD,IAAKmD,KAAKlD,IAAM,IAEvD4E,EAAU3E,KAAKS,EAAKwC,KAAKnD,KAAKmD,KAAKlD,IAAM,IAEvCkD,KAAKnD,IAAMW,EAAKK,OAAS,IAAM+F,EAAe5D,KAAKnD,IAAM,EAAGmD,KAAKlD,MAEnE4E,EAAU3E,KAAKS,EAAKwC,KAAKnD,IAAM,GAAGmD,KAAKlD,MAGvCkD,KAAKlD,IAAMU,EAAKwC,KAAKnD,KAAKgB,OAAS,IAClC+F,EAAe5D,KAAKnD,IAAKmD,KAAKlD,IAAM,IAGrC4E,EAAU3E,KAAKS,EAAKwC,KAAKnD,KAAKmD,KAAKlD,IAAM,IAGpC4E,I,iCAQEpF,GAET,OAAI0D,KAAKnD,MAAQP,EAAKO,IACbmD,KAAKlD,IAAM,IAAMR,EAAKQ,KAAOkD,KAAKlD,IAAM,IAAMR,EAAKQ,IACxDkD,KAAKlD,MAAQR,EAAKQ,MACbkD,KAAKnD,IAAM,IAAMP,EAAKO,KAAOmD,KAAKnD,IAAM,IAAMP,EAAKO,O,oCAQhDgH,GACZ,OAAI7D,OAAS6D,EAAY,EACpB7D,KAAK8D,WAAWD,GACdA,EAAIpB,YADuBe,M,kCAQlC,OAAIxD,KAAKuB,GAAGvE,GAAoB,GAC5BgD,KAAKuB,GAAGvE,GAAkBwG,IAC1BxD,KAAKuB,GAAGvE,IAAuB,EAC5B,I,kCAMG+G,GACV/D,KAAKtD,QAAQ8E,OAAOuC,K,mCAOpB/D,KAAKf,KAAO+B,SAASgD,eAAT,UAA2BhE,KAAKnD,IAAhC,YAAuCmD,KAAKlD,MACxDkD,KAAKtD,QAAUsD,KAAKf,KAAKgF,Y,iCAOzB,MAAO,IAAMjE,KAAKnD,IAAM,IAAMmD,KAAKlD,IAAM,M,gCAOrCkD,KAAKrC,eACTqC,KAAKwB,OAAO,CRjFQ,WACE,cQiFtBxB,KAAKpC,IAAIZ,M,oCAOTgD,KAAKpC,IAAIZ,GACTgD,KAAKkE,qB,0CAOLlE,KAAKwB,OAAOxE,GACZgD,KAAKpC,IR/FuB,qB,qCQsGxBoC,KAAKuB,GAAGvE,IACZgD,KAAKpC,IR1Ge,c,sCQiHhBoC,KAAKuB,GAAGvE,IACZgD,KAAKpC,IRjHiB,e,0CQwHlBoC,KAAKuB,GAAGvE,IAAegD,KAAKuB,GAAGvE,IACnCgD,KAAKpC,IRxHoB,mB,sCQ+HzBoC,KAAKwB,OAAO,CRlIa,eACL,WACE,YACG,kBQgIzBxB,KAAKuD,YAAc,KACnBvD,KAAK6B,KAAO2B,M,sCAMG,IAAD,OACdxD,KAAKtD,QAAQyH,SACX,SAACC,GAAD,MRlJc,SQmJZA,GACAA,IAASpH,GACToH,IAASpH,GACToH,IAASpH,GACT,EAAKN,QAAQ8E,OAAO4C,Q,8BAKxBpE,KAAKwB,OAAO,CRtJa,eQsJOxE,ERrJZ,WQqJoCA,IACxDgD,KAAKwB,OAAO,CRrJU,YAEM,kBADH,kBQqJzBxB,KAAKwB,OAAO,CAACxE,IACbgD,KAAKuD,YAAc,KACnBvD,KAAK6B,KAAO2B,M,mCAOZ,OACExD,KAAKuB,GAAGvE,IAAegD,KAAKuB,GAAGvE,IAAcgD,KAAKuB,GR9JxB,qB,yCQsKvBvB,KAAKuB,GAAGvE,IAAgBgD,KAAKuB,GAAGvE,KACnCgD,KAAKwB,OAAO,CR1KM,WACE,YACG,kBQyKvBxB,KAAKpC,IR5KkB,iBQ8KA,OAArBoC,KAAKuD,aACTvD,KAAKuD,YAAYW,qB,6BAOZxH,GACL,IAAK,IAAIgB,KAAKhB,EAASsD,KAAKtD,QAAQ8E,OAAO9E,EAAQgB,M,yBAOlD2G,GACD,OAAOrE,KAAKtD,QAAQ4H,SAASD,K,0BAO3BA,GACFrE,KAAKtD,QAAQkB,IAAIyG,K,8BAOjBrE,KAAKtD,QAAU,CRpNC,Y,KQ6NpB4G,EAAKiB,QAAU,SAAC1J,EAAI2J,GAClB,IAAMxG,EAAQwG,EAAS,GAAG3G,OAEpBf,GAAOjC,EAAK,GAAKmD,EACvB,OAAOwG,EAFKtI,KAAKC,OAAOtB,EAAK,GAAKmD,IAEblB,I,IC9PF2H,EACnB,WAAYC,EAAYC,EAAUC,EAAWC,GAA+C,IAAhCC,EAA+B,wDAARC,EAAQ,2DACzF/E,KAAK0E,WAAaA,EAClB1E,KAAK2E,SAAWA,EAChB3E,KAAK4E,UAAYA,EACjB5E,KAAK8E,cAAgBA,EACrB9E,KAAK6E,cAAgBA,EACrB7E,KAAK+E,OAASA,GCALhE,EAAb,WACE,WAAYiE,GAAe,oBACzBhF,KAAKgF,aAAeA,EACpBhF,KAAKI,QAAU,IAAI6E,IAHvB,sDAWYC,GAGRlF,KAAKI,QAAQV,IAAIwF,EAAG,MAdxB,8BAuBUA,EAAGC,GAGTnF,KAAKI,QAAQC,IAAI6E,GAAGnI,KAAKoI,KA1B7B,mCAqCI,IAFW,EAEPC,EAAWpF,KAAKI,QAAQrF,OAFjB,cAKGqK,GALH,IAKX,2BAAwB,CAAC,IAAD,EAAf1H,EAAe,QAGlB2H,EAAarF,KAAKI,QAAQC,IAAI3C,GAC9B4H,EAAO,GAJW,cAQRD,GARQ,IAQtB,4BAA0BC,GAA1B,QAAsC,KARhB,8BAWtBC,QAAQC,IAAI9H,EAAI,OAAS4H,IAhBhB,iCAnCf,0BA6DMG,EAAcZ,GAMhB,IAJA,IAAMH,EAAa,GAGfgB,EAAU,GACLhI,EAAI,EAAGA,EAAIsC,KAAKgF,aAActH,IAAKgI,EAAQhI,IAAK,EAGzD,IAAIiI,EAAI,IAAI7D,EAGZ4D,EAAQD,IAAgB,EACxBE,EAAEC,QAAQH,GAMV,IAJA,IAAI5D,EAAO,EACPgE,GAAe,GAGXF,EAAE1D,WAAW,CAGnB,IAFA,IAAM6D,EAAOH,EAAEG,OAENpI,EAAI,EAAGA,EAAIoI,EAAMpI,IAAK,CAE7B,IAAIqI,EAAkBJ,EAAEK,UAGpBD,EAAgBxE,GAAGvE,KAAa6I,EAAchE,GAIlD,IAAIoE,EAAWjG,KAAKI,QAAQC,IAAI0F,GAIhC,IAAK,IAAIG,KAAKD,EAAU,CACtB,IAAIE,EAAQF,EAASC,GAEhBR,EAAQS,KACXA,EAAM5C,YAAcwC,EACpBI,EAAMtE,KAAO,EAAIkE,EAAgBlE,KAC5BgD,GAAesB,EAAMC,oBACtBD,EAAM5E,GAAGvE,KAAgB6H,GAC3BsB,EAAMjC,mBAERQ,EAAW3H,KAAKoJ,GAChBT,EAAQS,IAAS,EACjBR,EAAEC,QAAQO,KAIhBtE,IAGF,OAAO,IAAI4C,EAAYC,EAAYmB,EAAa7I,EAAS6H,KAnH7D,0BA4HMY,EAAcZ,GAChB,IAAKY,EAAc,MAAO,GAC1B,IAAMf,EAAa,GAIbC,EAAW3E,KAAKqG,QACpBZ,EAHY,GAKZf,EACAG,GAGF,OAAO,IAAIJ,EAAYC,EAAYC,EAAU3H,EAAS6H,KAzI1D,8BAsJUyB,EAAMZ,EAAShB,EAAYG,GACjCa,EAAQY,IAAQ,EAChB,IAAIC,GAAU,EACVD,EAAK/E,GAAGvE,KAAauJ,EAASD,EAAKzE,MAEvC,IALgD,EAK5CH,EAAY1B,KAAKI,QAAQC,IAAIiG,GALe,cAO3B5E,GAP2B,IAOhD,2BAAgC,CAAC,IAAxB8E,EAAuB,QAC9BA,EAAS3E,KAAOyE,EAAKzE,KAAO,EACtB2E,KAAYd,IAChBc,EAASjD,YAAc+C,EAClBzB,GAAe2B,EAASJ,oBAEzBI,EAASjF,GAAGvE,KAAgB6H,GAC9B2B,EAAStC,mBAEXQ,EAAW3H,KAAKyJ,GAChBD,EAASrK,KAAKD,IACZ+D,KAAKqG,QAAQG,EAAUd,EAAShB,EAAYG,GAC5C0B,KAnB0C,8BAwBhD,OAAOA,IA9KX,+BA0LWnF,EAAWyD,GAClB,IAAKzD,EAAW,MAAO,GAEvB,IAAMsD,EAAa,GAEbgB,EAAU,GAGVe,EAAO,IAAIC,GAAQ,SAACtC,GAAD,OAAUA,EAAKvC,QAExC4E,EAAK1J,KAAKqE,GAKV,IAFA,IAAIyE,GAAe,GAEXY,EAAKxE,WAAW,CAEtB,IAAMX,EAAcmF,EAAKE,MAGzB,GAAIrF,EAAYC,GAAGvE,GAAa,CACzB6H,GAAevD,EAAY4C,mBAChC2B,EAAcvE,EAAYO,KAC1B,MAIF,IAZsB,EAYlBH,EAAY1B,KAAKI,QAAQC,IAAIiB,GAZX,cAeGI,GAfH,IAetB,2BAAoC,CAAC,IAA5BkF,EAA2B,QAElC,KAAIA,KAAgBlB,GAApB,CACAA,EAAQkB,IAAgB,EAExB,IAAIC,EAAoBD,EAAanE,YAAcnB,EAAYO,KAE3DgF,EAAoBD,EAAa/E,OAI9BgD,GAAe+B,EAAaR,oBACjC1B,EAAW3H,KAAK6J,GAEhBH,EAAK1J,KAAK6J,GAGVA,EAAarD,YAAcjC,EAG3BsF,EAAa/E,KAAOgF,KAnCF,+BAwCxB,OAAO,IAAIpC,EACTC,EACAmB,EV5PkB,WU8PlBhB,KArPN,4BAgQQzD,EAAWC,EAAYwD,GAC3B,GAAkB,OAAdzD,EAAoB,MAAO,GAC/B,GAAmB,OAAfC,EAAqB,MAAO,GAGhC,IAAMqE,EAAU,GAGVhB,EAAa,GAGb+B,EAAO,IAAIC,GAAQ,SAACtC,GAAD,OAAUA,EAAKT,KAGxCvC,EAAUuC,EAAI3D,KAAK8G,kBAAkB1F,EAAWC,GAEhDoF,EAAK1J,KAAKqE,GAIV,IAFA,IAAIyE,GAAe,GAEXY,EAAKxE,WAAW,CAEtB,IAAMX,EAAcmF,EAAKE,MAGrBI,EAAczF,EAAYO,KAG1BmF,EAAMhH,KAAKI,QAAQC,IAAIiB,GAM3B,GAHKuD,GAAevD,EAAY8E,oBAChC1B,EAAW3H,KAAKuE,GAEZA,EAAYC,GAAGvE,GAAa,CACzB6H,GAAevD,EAAY4C,mBAChC2B,EAAcvE,EAAYO,KAC1B,MAjBoB,oBAqBGmF,GArBH,IAqBtB,2BAA8B,CAAC,IAAtBJ,EAAqB,QAC5B,KAAIA,KAAgBlB,GAApB,CACAA,EAAQkB,IAAgB,EAGxB,IAAIK,EAAkBF,EAAcH,EAAanE,YAEjD,GAAIwE,EAAkBL,EAAa/E,KAAM,CAIvC+E,EAAarD,YAAcjC,EAE3BsF,EAAa/E,KAAOoF,EAGpB,IAAMxD,EAAImD,EAAa/E,KAEjB6B,EAAI1D,KAAK8G,kBAAkBF,EAAcvF,GAE/CuF,EAAajD,EAAIF,EAAIC,EAErB+C,EAAK1J,KAAK6J,MA3CQ,+BAiDxB,OAAO,IAAInC,EAAYC,EAAYmB,EV7UlB,KU6U0ChB,KArU/D,wCA8UoBvI,EAAM+E,GACtB,OACEnF,KAAKgL,IAAI5K,EAAKQ,IAAMuE,EAAWvE,KAAOZ,KAAKgL,IAAI5K,EAAKO,IAAMwE,EAAWxE,OAhV3E,sCA0VkBuE,EAAWC,EAAYwD,GACrC,GAAkB,OAAdzD,EAAoB,MAAO,GAC/B,GAAmB,OAAfC,EAAqB,MAAO,GAGhC,IAAMqE,EAAU,GAGVhB,EAAa,GAGb+B,EAAO,IAAIC,GAAQ,SAACtC,GAAD,OAAUA,EAAKT,KAExCvC,EAAUqC,EAAI,EACdzD,KAAKmH,gBAAgB/F,EAAWC,GAGhCoF,EAAK1J,KAAKqE,GAIV,IAFA,IAAIuD,GAAY,GAER8B,EAAKxE,WAAW,CAEtB,IAAMX,EAAcmF,EAAKE,MAGzB,GAAIrF,EAAYC,GAAGvE,GAAa,CAC9B0H,EAAW3H,KAAKuE,GACXuD,GAAevD,EAAY4C,mBAChCS,EAAWrD,EAAYO,KACvB,MAGF,IAAIkF,EAAczF,EAAYO,KAG1BmF,EAAMhH,KAAKI,QAAQC,IAAIiB,GAO3B,IAAK,IAAI8F,KAJJvC,GAAevD,EAAY8E,oBAChC1B,EAAW3H,KAAKuE,GAGF0F,EAAK,CACjB,IAAMJ,EAAeI,EAAII,GAGrBC,EAAIT,EAAanE,YAAcsE,IAG7BH,EAAa/L,MAAM6K,IAAY2B,EAAIT,EAAa/E,OACpD7B,KAAKmH,gBAAgBP,EAAcvF,GAE9BoF,EAAKnC,SAASsC,IAAeH,EAAK1J,KAAK6J,GAG5CA,EAAarD,YAAcjC,EAC3BsF,EAAa/E,KAAOwF,EAGpB3B,EAAQkB,EAAa/L,KAAM,IAKjC,OAAO,IAAI4J,EAAYC,EAAYC,EAAU3H,EAAgB6H,KA3ZjE,sCAoakBvI,EAAM+E,GAEpB,IAAMqC,EAAIxH,KAAKoL,KACbpL,KAAKqL,IAAIjL,EAAKQ,IAAMuE,EAAWvE,IAAK,GAClCZ,KAAKqL,IAAIjL,EAAKO,IAAMwE,EAAWxE,IAAK,IAExCP,EAAKoH,EAAIxH,KAAKC,MAAMuH,GACpBpH,EAAKqH,EAAIrH,EAAKoH,IA3alB,wCAoboBpH,EAAM+E,GACtB,IAAMqC,EAAIxH,KAAKoL,KACbpL,KAAKqL,IAAIjL,EAAKQ,IAAMuE,EAAWvE,IAAK,GAClCZ,KAAKqL,IAAIjL,EAAKO,IAAMwE,EAAWxE,IAAK,IAExCP,EAAKoH,EAAIxH,KAAKC,MAAMuH,GACpBpH,EAAKqH,EAAIrH,EAAKmG,YAAcnG,EAAKoH,IA1brC,4BAocQtC,EAAWC,EAAYwD,GAC3B,GAAmB,OAAfxD,EAAqB,MAAO,GAEhC,IAAMmG,EAAQ,IAAI1F,EACZ4C,EAAa,GAEnBrD,EAAWQ,KAAO,EAClB2F,EAAM5B,QAAQvE,GAId,MAAQmG,EAAMvF,WAAW,CACvB,IADuB,EACjBX,EAAckG,EAAMxB,UACpBgB,EAAMhH,KAAKI,QAAQC,IAAIiB,GAFN,cAGF0F,GAHE,IAGvB,2BAA0B,CAAC,IAAlBR,EAAiB,QAClB3E,EAAO,EAAIP,EAAYO,KAC7B,GAAIA,EAAO2E,EAAS3E,MAAQ2E,EAASjF,GAAGvE,GAAY,CAKlD,GAJK6H,GAAe2B,EAASJ,oBAC7B1B,EAAW3H,KAAKyJ,GAChBA,EAAS3E,KAAOA,EAChB2E,EAASjD,YAAcjC,EACnBkF,IAAapF,EAAW,CACrByD,GACH2B,EAAStC,mBAEX,MAEFsD,EAAM5B,QAAQY,KAhBK,+BAqBzB,OAAO,IAAI/B,EAAYC,GAvBJ,EVhdF,KUue0CG,KApe/D,4BA8eQzD,EAAWC,EAAYwD,GAC3B,GAAkB,OAAdzD,EAAoB,MAAO,GAC/B,GAAmB,OAAfC,EAAqB,MAAO,GAEhC,IAAMoF,EAAO,IAAIC,GAAQ,SAACpK,GAAD,OAAUA,EAAKuF,QAClC4F,EAAM,GACN/C,EAAa,GAInB,IAHAtD,EAAUS,KAAO,EACjB4E,EAAK1J,KAAKqE,IAEFqF,EAAKxE,WAAW,CACtB,IAAMX,EAAcmF,EAAKE,MAEnBe,EAAgB1H,KAAKI,QAAQC,IAAIiB,GAEvCoD,EAAW3H,KAAKuE,GALM,oBAONoG,GAPM,IAOtB,2BAA+B,CAAC,IAAvBV,EAAsB,QACzBA,EAAInF,KAAOmF,EAAIvE,eAChBoC,GAAiBmC,EAAIZ,oBACtBK,EAAK1J,KAAKiK,GACVA,EAAInF,KAAOmF,EAAIvE,cAXG,8BAetBgF,EAAInG,EAAYqG,YAAcrG,EAKhC,OAFKuD,GAAexD,EAAW6C,mBAExB,IAAIO,EAAYC,EAAY1H,EAASA,EAAW6H,KA5gB3D,gCAohBI,IAAM4B,EAAO,IAAIC,GAAQ,SAACkB,GAAD,OAAQA,EAAGzC,KAG9B0C,EAAK,IAAIzF,EAAY,KACrBqF,EAAM,GACNK,EAAQ,GACRpD,EAAa,GAsBnB,IAnBA1E,KAAKI,QAAQ+D,SAAQ,SAAC4D,EAAKC,GACzBD,EAAI5D,SAAQ,SAAC6C,GACX,IAAMiB,EAAS,CAACD,EAAInN,GAAImM,EAAInM,IAC5BoN,EAAOC,MAAK,SAACd,EAAGe,GAAJ,OAAUf,EAAIe,KAGrBL,EAAMM,eAAeH,EAAON,cAC/BG,EAAMG,IAAU,EAChBxB,EAAK1J,KAAK,CACRsL,MAAO,CAACL,EAAKhB,GACb7B,EAAG6C,EAAIvF,YAAcuE,EAAIvE,YAAc,EACvC/E,EAAGsK,EAAInN,GACPiD,EAAGkJ,EAAInM,aAOP4L,EAAKxE,WAAW,CACtB,IAAMqG,EAAc7B,EAAKE,MACRkB,EAAGjF,SAAS0F,EAAY5K,EAAG4K,EAAYxK,KAItD4G,EAAW3H,KAAKuL,EAAYD,MAAM,IAClC3D,EAAW3H,KAAKuL,EAAYD,MAAM,IAClCZ,EAAI1K,KAAKuL,IAIb,OAAO,IAAI7D,EAAYC,EAAY1H,EAASA,GAAa,KA5jB7D,kCAqkBcoE,EAAWC,EAAYmD,EAAUK,GAC3C,GAAkB,OAAdzD,EAAoB,MAAO,GAE/BA,EAAUS,KAAO,EASjB,IANA,IAAMwG,EAAQ,GAGRnC,EAAI1B,EAAS3G,OAAS2G,EAAS,GAAG3G,OAG/BhD,EAAK,EAAGA,GAAMqL,EAAGrL,IAAM,CAE9B,IAAMyB,EAAOgH,EAAKiB,QAAQ1J,EAAI2J,GAC9B6D,EAAMxN,GAAMyB,EAId,IAAIoI,EAAU,YAAO1J,OAAOuN,OAAOF,IACnC3D,EAAaA,EAAW8D,QAAO,SAAClM,GAAD,OAAWA,EAAKiF,GAAGvE,MAGlD,IAAK,IAAIU,EAAI,EAAGA,EAAIsC,KAAKgF,aAActH,IAErCsC,KAAKI,QAAQ+D,SAAQ,SAAC4D,EAAKC,GACzBD,EAAI5D,SAAQ,SAAC6C,GACPgB,EAAInG,KAAOmF,EAAInF,KAAOmF,EAAIvE,cAC5BuF,EAAInG,KAAOmF,EAAInF,KAAOmF,EAAIvE,YAC1BuF,EAAIzE,YAAcyD,SAM1B,IAAIyB,GAAwB,EAkB5B,OAfAzI,KAAKI,QAAQ+D,SAAQ,SAAC4D,EAAKC,GACzBD,EAAI5D,SAAQ,SAAC6C,GACPA,EAAInF,KAAOmF,EAAIvE,YAAcuF,EAAInG,OACnC4G,GAAwB,SAK1BA,GAEFzI,KAAKI,QAAQ+D,SAAQ,SAAC4D,EAAKC,GACzBA,EAAIzE,YAAc,QAIf,IAAIkB,EACTC,EACArD,EAAWQ,KV5nBW,eU8nBtBgD,EACA4D,KA/nBN,uCAwoBmBrH,EAAWC,GAC1B,IAAMqD,EAAa,GACbgB,EAAU,GACV8B,EAAQ,IAAI1F,EAMlB,IALA0F,EAAM5B,QAAQxE,GACdoG,EAAM5B,QAAQvE,GACdqE,EAAQtE,IAAa,EACrBsE,EAAQrE,IAAc,GAEdmG,EAAMvF,WAEZ,IADA,IAAM6D,EAAO0B,EAAM1B,OACVpI,EAAI,EAAGA,EAAIoI,EAAMpI,IAAK,CAC7B,IAD6B,EACvBgL,EAAOlB,EAAMxB,UACbtE,EAAY1B,KAAKI,QAAQC,IAAIqI,GAFN,cAIXhH,GAJW,IAI7B,2BAA6B,CAAC,IAArByE,EAAoB,QACvBA,KAAST,IAGbhB,EAAW3H,KAAKoJ,GAChBA,EAAM5C,YAAcmF,EACpBhD,EAAQS,IAAS,EACjBqB,EAAM5B,QAAQO,KAXa,+BAgBjC,OAAO,IAAI1B,EACTC,EACArD,EAAWQ,KVpqBgB,qBUsqB3B,OAvqBN,KCAa6E,EAAb,WAME,WAAYiC,GAAW,yBAFvBA,SAAW,KAGT3I,KAAK+B,MAAQ,GACb/B,KAAK2I,SAAWA,EARpB,mDAeI,OAAO3I,KAAK+B,MAAM,KAftB,2BAsBOqC,GACH,IAAI1G,EAAIsC,KAAK+B,MAAMlE,OACnBmC,KAAK+B,MAAMhF,KAAKqH,GAOhB,IALA,IAAIwE,EAAc5I,KAAK6I,eAAenL,GAElCoL,EAAY9I,KAAK2I,SAAS3I,KAAK+B,MAAM6G,IACnCG,EAAY/I,KAAK2I,SAAS3I,KAAK+B,MAAMrE,IAEpCoL,EAAYC,GACjB/I,KAAKgJ,KAAKtL,EAAGkL,GAEblL,EAAIkL,EACJA,EAAc5I,KAAK6I,eAAenL,GAElCoL,EAAY9I,KAAK2I,SAAS3I,KAAK+B,MAAM6G,MArC3C,qCA+CiBK,GACb,OAAO/M,KAAKD,IAAIC,KAAKC,OAAO8M,EAAQ,GAAK,GAAI,KAhDjD,oCAwDgBA,GACZ,OAAO,EAAIA,EAAQ,IAzDvB,mCAiEeA,GACX,OAAO,EAAIA,EAAQ,IAlEvB,2BA0EOvL,EAAGI,GACN,IAAIhD,EAAIkF,KAAK+B,MAAMrE,GACnBsC,KAAK+B,MAAMrE,GAAKsC,KAAK+B,MAAMjE,GAC3BkC,KAAK+B,MAAMjE,GAAKhD,IA7EpB,4BAqFI,GAAIkF,KAAK+B,MAAMlE,QAAU,EAAG,OAAOmC,KAAK+B,MAAM4E,MAC9C,IAAMuC,EAAMlJ,KAAK+B,MAAM,GACnBoH,EAAOnJ,KAAK+B,MAAM4E,MACtB3G,KAAK+B,MAAM,GAAKoH,EAIhB,IAFA,IAAIzL,EAAI,IAEK,CACX,IAAI0L,EAAkBpJ,KAAKqJ,cAAc3L,GACrC4L,EAAiBtJ,KAAKuJ,aAAa7L,GAEnC8L,EAASJ,EAETK,EAAcH,GAAkBtJ,KAAK+B,MAAMlE,OAC3C6L,EAAeN,GAAmBpJ,KAAK+B,MAAMlE,OAGjD,GAAI4L,GAAeC,EAAc,MAkBjC,GAfID,IAAaD,EAASJ,GAEtBM,IAAcF,EAASF,IAECG,IAAgBC,IAG1CF,EACExJ,KAAK2I,SAAS3I,KAAK+B,MAAMqH,IACzBpJ,KAAK2I,SAAS3I,KAAK+B,MAAMuH,IACrBF,EACAE,KAIJtJ,KAAK2I,SAAS3I,KAAK+B,MAAMrE,IAAMsC,KAAK2I,SAAS3I,KAAK+B,MAAMyH,KAI1D,MAHAxJ,KAAKgJ,KAAKtL,EAAG8L,GACb9L,EAAI8L,EAOR,OAAON,IAjIX,+BAwIW9E,GACP,OAAOpE,KAAK+B,MAAM4H,SAASvF,KAzI/B,gCAiJI,OAA6B,IAAtBpE,KAAK+B,MAAMlE,SAjJtB,6BAwJSuG,GACL,IAAI1G,EAAIsC,KAAK+B,MAAM6H,QAAQxF,GAG3B,IADApE,KAAK+B,MAAMrE,GAAKsC,KAAK+B,MAAM4E,QACd,CACX,IAAI6C,EACFxJ,KAAK2I,SAAS3I,KAAK+B,MAAM/B,KAAKqJ,cAAc3L,KAC5CsC,KAAK2I,SAAS3I,KAAK+B,MAAgB,GAATrE,EAAI,GAAS,IACzB,GAATA,EAAI,GACK,GAATA,EAAI,GAAS,EACpB,KAAIsC,KAAK2I,SAAS3I,KAAK+B,MAAMrE,IAAMsC,KAAK2I,SAAS3I,KAAK+B,MAAMyH,KAKrD,MAJL,IAAI1O,EAAIkF,KAAK+B,MAAMrE,GACnBsC,KAAK+B,MAAMrE,GAAKsC,KAAK+B,MAAMyH,GAC3BxJ,KAAK+B,MAAMyH,GAAU1O,EACrB4C,EAAI8L,KAtKZ,8BA+KI,IAAK,IAAI9L,EAAI,EAAGA,EAAIsC,KAAK+B,MAAMlE,OAAQH,IACrC6H,QAAQC,IAAIxF,KAAK+B,MAAMrE,MAhL7B,8BAwLUqK,GACN,IAAK,IAAIrK,EAAI,EAAGA,EAAIqK,EAAIlK,OAAQH,IAC9BsC,KAAKjD,KAAKgL,EAAIrK,QA1LpB,KC8GA,SAAS6G,GAAQ1J,EAAI2J,GACnB,IAAMxG,EAAQwG,EAAS,GAAG3G,OAEpBf,GAAOjC,EAAK,GAAKmD,EACvB,OAAOwG,EAFKtI,KAAKC,OAAOtB,EAAK,GAAKmD,IAEblB,G,MAShB,IChCQ+M,GAlFK,SAACC,EAAMC,GAAU,IAAD,EACJC,mBAASF,GADL,mBAC3BtN,EAD2B,KAClByN,EADkB,OAEJD,mBAASD,GAFL,mBAE3BtN,EAF2B,KAElByN,EAFkB,KAI5B1F,EAAW2F,sBAnBM,SAAC3N,EAASC,GAIjC,IAHA,IAAMqE,EAAY,GACdjG,EAAK,EAEAgC,EAAM,EAAGA,EAAML,EAASK,IAAO,CACtCiE,EAAUjE,GAAO,GACjB,IAAK,IAAIC,EAAM,EAAGA,EAAML,EAASK,IAC/BgE,EAAUjE,GAAKC,GAAO,IAAIwG,EAAKzG,EAAKC,EAAKjC,GACzCA,IAIJ,OAAOiG,EAOsBD,CAAiBrE,EAASC,GAAU,CAC/DD,EACAC,IAWI2N,EAAY,WAChB,IAAK,IAAIvN,KAAO2H,EAAU,CAAC,IAAD,gBACPA,EAAS3H,IADF,IACxB,2BAAgC,CAAC,IAAxBoC,EAAuB,QAC9BA,EAAKoL,QACLpL,EAAKuC,OAAO,CAACxE,EAAWA,KAHF,iCA4C5B,MAAO,CACLwH,WACA8F,UAvDgB,WAChB,IAAK,IAAIzN,KAAO2H,EAAU,CAAC,IAAD,gBACPA,EAAS3H,IADF,IACxB,2BAAgC,SACzBwN,SAFiB,iCAuD1BE,cAvCoB,WACpB,IAAK,IAAI1N,KAAO2H,EAAU,CAAC,IAAD,gBACPA,EAAS3H,IADF,IACxB,2BAAgC,SACzB0N,iBAFiB,iCAuC1BC,gBAhCsB,SAAC3I,GACvB,GAAIA,IAAS2B,IACb,IAAK,IAAI3G,KAAO2H,EAAU,CAAC,IAAD,gBACPA,EAAS3H,IADF,IACxB,2BAAgC,CAAC,IAAxBP,EAAuB,QAC1BA,EAAKuF,MAAQA,EACfvF,EAAK8J,oBAEL9J,EAAKmO,iBALe,iCA+B1BC,cAjBoB,WACpB,IAAK,IAAI7N,KAAO2H,EAAU,CAAC,IAAD,gBACPA,EAAS3H,IADF,IACxB,2BAAgC,CAAC,IAAxBP,EAAuB,QAC9BA,EAAKuF,KAAO2B,IACZlH,EAAKiH,YAAc,KACdjH,EAAKqB,cACRrB,EAAKmO,iBALe,iCAiB1BL,YACAH,WAAY,SAACzN,GACX4N,IACAH,EAAWzN,IAEb0N,WAAY,SAACzN,GACX2N,IACAF,EAAWzN,IAEbD,UACAC,Y,wCCvFWkO,GAPQ,SAAC,GAAD,IAAGC,EAAH,EAAGA,SAAUC,EAAb,EAAaA,QAAb,IAAsBC,aAAtB,MAA8B,GAA9B,SACrB,yBAAK7N,UAAWP,KAAQiO,gBACtB,4BAAQI,QAASF,EAAS5N,UAAWP,KAAQsO,IAAKF,MAAOA,GACtDF,KCUQK,I,MAbE,SAAC,GAAyB,IAAvBL,EAAsB,EAAtBA,SAAUM,EAAY,EAAZA,MAC5B,OACE,yBAAKjO,UAAU,YACb,4BAAQA,UAAU,WACfiO,GAEH,yBAAKjO,UAAU,oBACZ2N,MCEMO,I,MATA,SAAC,GAAyB,IAAvBP,EAAsB,EAAtBA,SAAUM,EAAY,EAAZA,MAC1B,OACE,yBAAKjO,UAAU,UACb,4BAAQA,UAAU,aAAaiO,GAC/B,yBAAKjO,UAAU,kBAAkB2N,MCDxBQ,GAJE,SAAC,GAAyB,IAAxBR,EAAuB,EAAvBA,SAAUC,EAAa,EAAbA,QAC7B,OAAO,uBAAGE,QAASF,GAAUD,I,SCDzBS,GAAc,GACdC,GAAY,GACZC,GAAU,GAEDC,GAAW,WAA0B,IAAzBC,IAAwB,yDACzCC,EAAW1B,mBAASqB,IAAa,GAEjCM,EAAW,SAACC,EAAUC,GAC1B,IAAMC,EAAeP,GAAQK,GAAUP,GAAaQ,GACpDR,GAAW,6BAAQA,IAAgBS,GAFG,oBAIfR,IAJe,IAItC,2BAAkC,EAChCS,EADgC,SACvBV,KAL2B,gCAqBxC,OAZA1O,qBAAU,WAKR,OAJI8O,GACFH,GAAUvO,KAAK2O,GAGV,WACDD,IACFH,GAAYA,GAAU9C,QAAO,SAACwD,GAAD,OAAQA,IAAON,SAG/C,CAACA,EAAUD,IAEP,CAACJ,GAAaM,ICqSRM,GA3TS,SAAC,GAUlB,IATL5B,EASI,EATJA,MACA6B,EAQI,EARJA,iBACAtH,EAOI,EAPJA,UACAuH,EAMI,EANJA,QACAC,EAKI,EALJA,SACAC,EAII,EAJJA,WACAC,EAGI,EAHJA,MACAC,EAEI,EAFJA,cACAtC,EACI,EADJA,WAEM0B,EAAWH,IAAS,GAAO,GACjC,OACE,oCACE,kBAAC,GAAD,CAAgBX,QAASwB,GAAzB,SACA,kBAAC,GAAD,CAAQnB,MAAM,cACZ,kBAAC,GAAD,CAAUA,MnBvBM,YmBwBd,kBAAC,GAAD,CACEL,QAAS,WACPc,EAAS,WAAY,CAAEa,KnB1Bb,amB2BVb,EAAS,WAAY,CAAEc,KnB3Bb,emBwBd,UAQA,kBAAC,GAAD,CACE5B,QAAS,kBAAMc,EAAS,WAAY,CAAEa,KnBjC1B,emBgCd,eAMF,kBAAC,GAAD,CAAUtB,MnBrCG,MmBsCX,kBAAC,GAAD,CACEL,QAAS,WACPc,EAAS,WAAY,CAAEa,KnBxChB,OmByCPb,EAAS,WAAY,CAAEc,KnBzChB,SmBsCX,UAQA,kBAAC,GAAD,CAAU5B,QAAS,kBAAMc,EAAS,WAAY,CAAEa,KnB9CrC,SmB8CX,eAIF,kBAAC,GAAD,CAAUtB,MAAOlO,GACf,kBAAC,GAAD,CACE6N,QAAS,WACPc,EAAS,WAAY,CAAEa,KAAMxP,IAC7B2O,EAAS,WAAY,CAAEc,KAAMzP,MAHjC,UAQA,kBAAC,GAAD,CACE6N,QAAS,kBAAMc,EAAS,WAAY,CAAEa,KAAMxP,MAD9C,eAMF,kBAAC,GAAD,CAAUkO,MAAOlO,GACf,kBAAC,GAAD,CACE6N,QAAS,WACPc,EAAS,WAAY,CAAEc,KAAMzP,IAC7B2O,EAAS,WAAY,CAAEa,KAAMxP,MAHjC,UAQA,kBAAC,GAAD,CAAU6N,QAAS,kBAAMc,EAAS,WAAY,CAAEa,KAAMxP,MAAtD,eAIF,kBAAC,GAAD,CAAUkO,MAAOlO,GACf,kBAAC,GAAD,CACE6N,QAAS,WACPc,EAAS,WAAY,CAAEa,KAAMxP,IAC7B2O,EAAS,WAAY,CAAEc,KAAMzP,MAHjC,UAQA,kBAAC,GAAD,CACE6N,QAAS,WACPc,EAAS,WAAY,CAAEa,KAAMxP,MAFjC,eAQF,kBAAC,GAAD,CAAUkO,MAAOlO,GACf,kBAAC,GAAD,CACE6N,QAAS,WACPc,EAAS,WAAY,CAAEa,KAAMxP,IAC7B2O,EAAS,WAAY,CAAEc,KAAMzP,MAHjC,UAQA,kBAAC,GAAD,CACE6N,QAAS,WACPc,EAAS,WAAY,CAAEa,KAAMxP,MAFjC,eAQF,kBAAC,GAAD,CAAUkO,MAAOlO,GACf,kBAAC,GAAD,CACE6N,QAAS,WACPc,EAAS,WAAY,CAAEa,KAAMxP,IAC7B2O,EAAS,WAAY,CAAEc,KAAMzP,MAHjC,UAQA,kBAAC,GAAD,CACE6N,QAAS,WACPc,EAAS,WAAY,CAAEa,KAAMxP,MAFjC,eAQF,kBAAC,GAAD,CAAUkO,MnB1HY,kBmB2HpB,kBAAC,GAAD,CACEL,QAAS,WACPc,EAAS,WAAY,CAAEa,KnB7HP,mBmB8HhBb,EAAS,WAAY,CAAEc,KnB9HP,qBmB2HpB,UAQA,kBAAC,GAAD,CACE5B,QAAS,WACPc,EAAS,WAAY,CAAEa,KAAMxP,MAFjC,eAQF,kBAAC,GAAD,CAAUkO,MnB7IG,MmB8IX,kBAAC,GAAD,CACEL,QAAS,WACPc,EAAS,WAAY,CAAEc,KnBhJhB,OmBiJPd,EAAS,WAAY,CAAEa,KnBjJhB,SmB8IX,UAQA,kBAAC,GAAD,CAAU3B,QAAS,kBAAMc,EAAS,WAAY,CAAEa,KnBtJrC,SmBsJX,eAIF,kBAAC,GAAD,CAAUtB,MnBvJU,gBmBwJlB,kBAAC,GAAD,CACEL,QAAS,WACPc,EAAS,WAAY,CAAEc,KnB1JT,iBmB2Jdd,EAAS,WAAY,CAAEa,KnB3JT,mBmBwJlB,UAQA,kBAAC,GAAD,CACE3B,QAAS,kBAAMc,EAAS,WAAY,CAAEa,KnBjKtB,mBmBgKlB,eAMF,kBAAC,GAAD,CAAUtB,MnBrKe,qBmBsKvB,kBAAC,GAAD,CACEL,QAAS,WACPc,EAAS,WAAY,CAAEc,KnBxKJ,sBmByKnBd,EAAS,WAAY,CAAEa,KnBzKJ,wBmBsKvB,UAQA,kBAAC,GAAD,CACE3B,QAAS,kBACPc,EAAS,WAAY,CAAEa,KnBhLJ,wBmB8KvB,gBASJ,kBAAC,GAAD,CAAQtB,MAAM,mBACZ,kBAAC,GAAD,CAAUA,MnBrLO,emBsLf,kBAAC,GAAD,CAAUL,QAAS,kBAAMsB,EnBtLV,cmBsLiCnP,KAAhD,kBAGA,kBAAC,GAAD,CAAU6N,QAAS,kBAAMsB,EnBzLV,cmByLiCnP,KAAhD,oBAGA,kBAAC,GAAD,CACE6N,QAAS,kBAAMc,EAAS,WAAY,CAAEa,KnB7LzB,kBmB4Lf,eAMF,kBAAC,GAAD,CAAUtB,MAAOlO,GACf,kBAAC,GAAD,CAAU6N,QAAS,kBAAMsB,EAAQnP,EAAgBA,KAAjD,4BAGA,kBAAC,GAAD,CAAU6N,QAAS,kBAAMsB,EAAQnP,EAAgBA,KAAjD,8BAGA,kBAAC,GAAD,CAAU6N,QAAS,kBAAMsB,EAAQnP,EAAoBA,KAArD,0BAGA,kBAAC,GAAD,CAAU6N,QAAS,kBAAMsB,EAAQnP,EAAoBA,KAArD,4BAGA,kBAAC,GAAD,CACE6N,QAAS,kBAAMc,EAAS,WAAY,CAAEa,KAAMxP,MAD9C,eAMF,kBAAC,GAAD,CAAUkO,MnBpNe,sBmBqNvB,kBAAC,GAAD,CAAUL,QAAS,kBAAMsB,EnBrNF,qBmBqNiCnP,KAAxD,kBAGA,kBAAC,GAAD,CAAU6N,QAAS,kBAAMsB,EnBxNF,qBmBwNiCnP,KAAxD,oBAGA,kBAAC,GAAD,CACE6N,QAAS,WACPc,EAAS,WAAY,CAAEa,KnB7NJ,yBmB2NvB,eAQF,kBAAC,GAAD,CAAUtB,MnBlOW,iBmBmOnB,kBAAC,GAAD,CAAUL,QAAS,kBAAMsB,EnBnON,gBmBmOiCnP,KAApD,kBAGA,kBAAC,GAAD,CAAU6N,QAAS,kBAAMsB,EnBtON,gBmBsOiCnP,KAApD,oBAGA,kBAAC,GAAD,CACE6N,QAAS,kBAAMc,EAAS,WAAY,CAAEa,KnB1OrB,oBmByOnB,gBAOJ,kBAAC,GAAD,CAAQtB,MAAM,WACZ,kBAAC,GAAD,CAAUA,MAAM,QACd,kBAAC,GAAD,CAAUL,QAAS,kBAAM0B,EnBvOX,cmBuOd,eAGA,kBAAC,GAAD,CAAU1B,QAAS,kBAAM0B,EnBzON,mBmByOnB,cAIF,kBAAC,GAAD,CAAUrB,MAAM,cACd,kBAAC,GAAD,CAAUL,QAAS,kBAAM0B,EnBrPN,mBmBqPnB,cAGA,kBAAC,GAAD,CAAU1B,QAAS,kBAAM0B,EnBtPJ,qBmBsPrB,uBAGA,kBAAC,GAAD,CAAU1B,QAAS,kBAAM0B,EnBpPN,mBmBoPnB,cAIF,kBAAC,GAAD,CAAUrB,MAAM,iBACd,kBAAC,GAAD,CACEL,QAAS,WACPZ,EAAW,MAFf,SAOA,kBAAC,GAAD,CACEY,QAAS,WACPZ,EAAW,MAFf,UAOA,kBAAC,GAAD,CAAUY,QAAS,kBAAMZ,EAAW,MAApC,0BAIF,kBAAC,GAAD,CAAUiB,MAAM,uBACd,kBAAC,GAAD,CACEL,QAAS,WACPuB,EAAS,OAFb,QAOA,kBAAC,GAAD,CACEvB,QAAS,WACPuB,EAAS,MAFb,UAOA,kBAAC,GAAD,CAAUvB,QAAS,kBAAMuB,EAAS,MAAlC,UAKJ,kBAAC,GAAD,CAAgBvB,QAASR,GAAzB,SACA,kBAAC,GAAD,CAAgBQ,QAASyB,GAAzB,uBACA,kBAAC,GAAD,CAAgBzB,QAASqB,EAAkBpB,MAAO,CAAE4B,MAAO,QAA3D,aACa9H,EADb,OClTS+H,GAPC,SAACC,GACf,OACE,4BAAQ3P,UAAWP,KAAQmQ,SACvB,kBAAC,GAAoBD,K,oBCOzBE,GAAW,KAETC,GAAYC,aAAW,CAC3BC,MAAO,CACLC,QAAS,MACTC,OAAQ,OACRnP,MAAO,SACPoP,UAAW,OACXC,aAAc,UA6aHC,GAraD,SAAC,GAAoB,IAAlBjB,EAAiB,EAAjBA,WACPzH,EAAc4G,KAAW,GAAzB5G,UACFlI,EAAUqQ,KAEhBxH,QAAQC,IAAI,SAJoB,MAe5BqE,GAjCY,GACA,IAwBdrF,EAP8B,EAO9BA,SACA8F,EAR8B,EAQ9BA,UACAC,EAT8B,EAS9BA,cACAG,EAV8B,EAU9BA,cACAT,EAX8B,EAW9BA,WACAC,EAZ8B,EAY9BA,WACA1N,EAb8B,EAa9BA,QACAC,EAd8B,EAc9BA,QAd8B,EAgBMuN,oBAAS,GAhBf,mBAgBzBuD,EAhByB,KAgBZC,EAhBY,OAiBIxD,oBAAS,GAjBb,mBAiBzByD,EAjByB,KAiBdC,GAjBc,QAkBY1D,oBAAS,GAlBrB,qBAkBzB2D,GAlByB,MAkBTC,GAlBS,SAmBU5D,oBAAS,GAnBnB,qBAmBzB6D,GAnByB,MAmBVC,GAnBU,SAoBsB9D,oBAAS,GApB/B,qBAoBzB+D,GApByB,MAoBJC,GApBI,SAqBUhE,qBArBV,qBAqBzBiE,GArByB,MAqBVC,GArBU,SAsBIlE,mBrBxBT,iBqBEK,qBAsBzBmE,GAtByB,MAsBb5B,GAtBa,SAuBYvC,mBAAS,IAvBrB,qBAuBzBoE,GAvByB,MAuBTC,GAvBS,SAwBArE,mBAASsE,GAxBT,qBAwBzB3J,GAxByB,MAwBf4J,GAxBe,SAyBJvE,mBAAS,MAzBL,qBAyBzBwE,GAzByB,MAyBjBC,GAzBiB,MA2B1BC,GAAoB,SAACpS,EAAMmB,GAC3BA,IAAS6Q,GAAahS,EAAKqS,cAC3BlR,IAAS6Q,GAAYhS,EAAKsB,IAAI0Q,GrBlDR,mBqBmDtBL,IAAuCvD,IAHH,MAKN4D,EAAiB9J,GAA3CpD,EALgC,EAKhCA,UAAWC,EALqB,EAKrBA,WAEnB,OAAQ4M,IACN,IrBhEkB,WqBiEhBW,IAAS,GACT,MACF,IrBlEe,KqBmEbC,IAAM,GACN,MACF,KAAKP,EACHQ,IAAgB,GAChB,MACF,KAAKR,EACHpT,IAAI,GACJ,MACF,KAAKoT,EACHnT,IAAI,GACJ,MACF,IrBzEe,KqB0Eb4T,IAAM,GACN,MACF,KAAKT,EACHU,IAAM,GACN,MACF,IrB7EwB,iBqB8EtBT,GAAYC,GAAOpN,EAAUvG,IAAIwG,EAAWxG,KAC5CoU,GAAS7N,EAAUvG,GAAIwG,EAAWxG,IAClC,MACF,IrBhFsB,eqBiFpBqU,IAAY,GACZ7N,EAAW6C,mBrBnFW,mBqByFxB+J,IrBxFsB,iBqByFtBA,IAEAM,GAAYlN,EAAWQ,OAAS2B,IAAW8K,EAAWjN,EAAWQ,OAG/DsN,GAAsB,SAAC7S,GAC3B,GAAKmR,EACL,OAAIM,GACKzR,EAAK8S,oBAEV7B,GAAeM,KAAkBvR,EAAKiF,GAAG+M,GACpCI,GAAkBpS,EAAMgS,GAE7Bf,GAAeI,KAAmBrR,EAAKiF,GAAG+M,GACrCI,GAAkBpS,EAAMgS,GrBrFR,kBqBuFrBH,IAAqCZ,EAChCjR,EAAK+S,eADd,GAKIC,GAAqB,SAAChT,GAE1B,GADAkR,GAAe,GACVC,EAAL,CACA,GrBtGyB,kBqBsGrBU,GACF,OAAQ7R,EAAKqB,cAAgBrB,EAAKsB,IAAI0Q,GACxC,GrBtG2B,oBqBsGvBH,GACF,OAAQ7R,EAAKqB,cAAgBrB,EAAKsB,IAAI0Q,GACxC,GrBpGoB,aqBoGhBH,GACF,OAAO7R,EAAKkF,OAAO,CAAC8M,EAAWA,IACjC,IAAKhS,EAAKqB,aAAc,OAAOrB,EAAK+S,UAChC/S,EAAKiF,GAAG+M,IAAaR,IAAiB,GACtCxR,EAAKiF,GAAG+M,IAAcV,IAAkB,KAGxC2B,GAAsB,SAACjT,GACtBmR,IACDI,IAAevR,EAAKkT,YAAYlB,GAChCX,IAAgBrR,EAAKkT,YAAYlB,KAGjCmB,GAAmB,WAEvBjC,GAAe,GACfM,IAAiB,GACjBF,IAAkB,IAGhB8B,GAAOlL,EAASvK,KAAI,SAAC4C,EAAK8S,GAC5B,OAAO9S,EAAI5C,KAAI,SAAC2V,EAAKC,GACnB,OACE,kBAAC,EAAD,CACE7H,IAAK4H,EACLtT,KAAMkI,EAASmL,GAAQE,GACvBtT,MAAO,CACLa,aAAc+R,GACdhS,YAAamS,GACbhS,UAAWmS,GACXpS,aAAckS,IAEhB/S,QAASA,EACTC,QAASA,UA0DXvB,GAAM,SAAC2J,GAAmB,IAAD,EACAyJ,EAAmB9J,GAAxCpD,EADqB,EACrBA,UAER,OAH6B,EACV3B,MACOqQ,IAAI1O,EAAWyD,IAIrC1J,GAAM,SAAC0J,GAAmB,IAAD,EACAyJ,EAAmB9J,GAAxCpD,EADqB,EACrBA,UAER,OAH6B,EACV3B,MACOsQ,IAAI3O,EAAWyD,IAIrC+J,GAAW,SAAC/J,GAAmB,IAAD,EACLyJ,EAAmB9J,GAAxCpD,EAD0B,EAC1BA,UAER,OAHkC,EACf3B,MACOuQ,SAAS5O,EAAWyD,IAI1CgK,GAAQ,SAAChK,GAAmB,IAAD,EACUyJ,EAAmB9J,GAApDpD,EADuB,EACvBA,UAAW3B,EADY,EACZA,MAAO4B,EADK,EACLA,WAE1B,OADoB5B,EAAMwQ,MAAM7O,EAAWC,EAAYwD,IAInDkK,GAAQ,SAAClK,GAAmB,IAAD,EACUyJ,EAAmB9J,GAApDpD,EADuB,EACvBA,UAAW3B,EADY,EACZA,MAAO4B,EADK,EACLA,WAE1B,OADoB5B,EAAMyQ,MAAM9O,EAAWC,EAAYwD,IAInDsL,GAAgB,WACpB,IAAMC,ETnPmB,SAAC5L,GAqB5B,IAnBA,IAKIG,EALEuB,EAAI1B,EAAS3G,OAAS2G,EAAS,GAAG3G,OAGlCwS,EAAO,GACP3L,EAAa,GAIb4L,EAAO,IAAIpN,MAAMgD,GAGjBmC,EAAQ,GAIVkI,EAAU,EACVC,EAAW,EAGN9S,EAAI,EAAGA,GAAKwI,EAAGxI,IAAK,CAE3B,IAAMpB,EAAOiI,GAAQ7G,EAAG8G,GAGxB6D,EAAM3K,GAAKpB,EAEXgU,EAAK5S,GAAK,GAEV4S,EAAK5S,GAAGA,GAAKA,EAGb,IAZ2B,EAYrBgE,EAAYpF,EAAKqF,aAAa6C,GAZT,cAeN9C,GAfM,IAe3B,2BAAgC,CAAC,IAAxB8E,EAAuB,QAC9B8J,EAAK5S,GAAG8I,EAAS3L,IAAM2L,EAAS3L,IAhBP,8BAoBvByB,EAAKiF,GAAGvE,KAAYuT,EAAUjU,EAAKzB,IACnCyB,EAAKiF,GAAGvE,KAAawT,EAAWlU,EAAKzB,IAGpCyB,EAAKiF,GAAGvE,IAAW0H,EAAW3H,KAAKT,GAI1C,IAAK,IAAIO,EAAM,EAAGA,GAAOqJ,EAAGrJ,IAAO,CACjCwT,EAAKxT,GAAO,GACZ,IAAK,IAAIC,EAAM,EAAGA,GAAOoJ,EAAGpJ,IAAO,CAEjC,IAAM2T,EAAQpI,EAAMxL,GAGdgH,EAAMwE,EAAMvL,GAEbwT,EAAKzT,GAAKC,KAAMwT,EAAKzT,GAAKC,GAAO,GAGtCuT,EAAKxT,GAAKC,GAAO2T,EAAMC,cAAc7M,IAKzC,IAAK,IAAI8M,EAAI,EAAGA,GAAKzK,EAAGyK,IACtB,IAAK,IAAIjT,EAAI,EAAGA,GAAKwI,EAAGxI,IACtB,IAAK,IAAII,EAAI,EAAGA,GAAKoI,EAAGpI,IAIlBuS,EAAK3S,GAAGiT,GAAKN,EAAKM,GAAG7S,GAAKuS,EAAK3S,GAAGI,KACpCuS,EAAK3S,GAAGI,GAAKuS,EAAK3S,GAAGiT,GAAKN,EAAKM,GAAG7S,GAClCwS,EAAK5S,GAAGI,GAAKwS,EAAK5S,GAAGiT,IAW7B,IALA,IAAIlI,GAAwB,EAKnB/K,EAAI,EAAGA,GAAKwI,EAAGxI,IACtB,GAAI2S,EAAK3S,GAAGA,GAAK,EAAG,CAClB+K,GAAwB,EACxB,MAWJ,OAPIA,GACF6H,EAAKnM,SAAQ,SAAC4D,GAAD,OAASA,EAAI5E,KAAK,MAIjCwB,EAAW0L,EAAKE,GAASC,GAElB,IAAI/L,EACTC,EACAC,EZlG0B,kBYoG1B,EACA8D,EACA,CAAE4H,OAAMC,SS0IYhC,CAAmB9J,GAIvC,OAHAsI,GAAWsD,EAAYrL,OAAOuL,KAC9B/B,GAAY6B,EAAYzL,UACxB8J,GAAU2B,EAAYrL,OAAOsL,MACtBD,GAGHtB,GAAkB,SAACjK,GAAmB,IAAD,EACAyJ,EAAmB9J,GAApDpD,EADiC,EACjCA,UAAW3B,EADsB,EACtBA,MAAO4B,EADe,EACfA,WAM1B,OALoB5B,EAAMqP,gBACxB1N,EACAC,EACAwD,IAKEmK,GAAQ,SAACnK,GAAmB,IAAD,EACUyJ,EAAmB9J,GAApDpD,EADuB,EACvBA,UAAW3B,EADY,EACZA,MAAO4B,EADK,EACLA,WAE1B,OADoB5B,EAAMuP,MAAM5N,EAAWC,EAAYwD,IAInD+L,GAAU,WAGd,OAFkBtC,EAAmB9J,GAA7B/E,MACkBoR,WAItB3B,GAAc,SAACrK,GAAmB,IAAD,EACIyJ,EAAmB9J,GAApD/E,EAD6B,EAC7BA,MAAO2B,EADsB,EACtBA,UAAWC,EADW,EACXA,WAO1B,OANoB5B,EAAMyP,YACxB9N,EACAC,EACAmD,EACAK,IAKEiM,GAAmB,WAAO,IAAD,EACYxC,EAAmB9J,GAApD/E,EADqB,EACrBA,MAAO2B,EADc,EACdA,UAAWC,EADG,EACHA,WAE1B,OADoB5B,EAAMqR,iBAAiB1P,EAAWC,IAIlD4N,GAAW,SAACsB,EAASC,GACzB,IADsC,EAChCO,ETnKa,SAACC,EAAG9L,EAAGoL,GAC5B,GAAmB,IAAfA,EAAKU,GAAG9L,GAAU,MAAO,GAE7B,IADA,IAAM+L,EAAS,GACRD,IAAM9L,GACX8L,EAAIV,EAAKU,GAAG9L,GACZ+L,EAAOlU,KAAKiU,GAEd,OAAOC,ES4JaC,CAAQX,EAASC,EAAU1D,IACzCqE,EAAW,KAFuB,cAInBJ,GAJmB,IAItC,2BAA8B,CAAC,IAAtBK,EAAqB,QACtB9U,EAAOgH,EAAKiB,QAAQ6M,EAAQ5M,GAClClI,EAAKiH,YAAc4N,EACnBA,EAAW7U,GAPyB,8BAStC6U,GAAYA,EAASjN,oBAGjBoI,GAAQ,WACPmB,IACLS,GAAiB,MACjBK,GAAYD,GACZG,GAAU,MACV3B,GAAW,KACXxC,MAGI+G,GAAsB,WACrB5D,IACLS,GAAiB,MACjBK,GAAYD,GACZ/D,MAkCI+G,GAAU,SAAClB,GAAiB,IACxB1L,EAAwC0L,EAAxC1L,WAAYC,EAA4ByL,EAA5BzL,SACpB,GADgDyL,EAAlBvL,cAC9B,CACA,GAAIH,EAAW7G,QAAU,EAAG,OAAO6P,IAAe,GAClD,IAAI6D,EAAQ,EACRC,EAAgB,KAEdC,EAAaC,aAAY,WAC7B,IAAMpV,EAAOoI,EAAW6M,GAyBxB,GAtBCjV,EAAKiF,GAAG+M,GAAqChS,EAAK8J,oBAA3B9J,EAAKqV,eAEzBrV,EAAKiF,GAAG+M,KrBtWY,mBqBuWlB1J,GACF2J,GAAY5J,GrBvWM,iBqB2WhBC,EACF4M,EAAgBlV,EAEhBA,EAAK4H,oBAIL5H,EAAKiF,GAAG+M,IrBrXG,OqBqXY1J,IACzBtI,EAAK4H,mBACLqK,GAAYjS,EAAKuF,SAGnB0P,GAEa7M,EAAW7G,OAAQ,CAG9B,GAFA6P,IAAe,GACfkE,cAAcH,GrB5XQ,mBqB6XlB7M,EAAmC,CAAC,IAAD,EACH0J,EAAiB9J,GAA3CpD,EAD6B,EAC7BA,UAAWC,EADkB,EAClBA,WACnB4N,GAAS7N,EAAUvG,GAAIwG,EAAWxG,IrB9XhB,iBqBiYhB+J,GACF4M,EAActN,sBAGjBkK,MAgBL,OACE,yBAAKnR,UAAU,eACb,kBAAC,GAAD,CACEoP,WAAYA,EACZhC,MAAOiC,GACP1H,UAAWA,EACXsH,iBA/PmB,WAEvB,GADAmF,KACK5D,EAAL,CACAC,IAAe,GACfQ,GAAiBtJ,GACjB2H,GrB/IyB,iBqBgJzB7B,IAEA,IAAIhG,EAAa,GAEjB,OAAQE,GACN,KAAK0J,EACH5J,EAAaxJ,IAAI,GACjB,MACF,KAAKoT,EACH5J,EAAavJ,IAAI,GACjB,MACF,IrBrLe,KqBsLbuJ,EAAamK,IAAM,GACnB,MACF,IrBzLkB,WqB0LhBnK,EAAakK,IAAS,GACtB,MACF,KAAKN,EACH5J,EAAaoK,IAAgB,GAC7B,MACF,IrBzLe,KqB0LbpK,EAAaqK,IAAM,GACnB,MACF,KAAKT,EACH5J,EAAasK,IAAM,GACnB,MACF,KAAKV,EACH5J,EAAakM,KACb,MACF,IrBhMwB,iBqBiMtBlM,EAAayL,IAAc,GAC3B,MACF,IrBlMsB,eqBmMpBzL,EAAawK,IAAY,GACzB,MACF,IrBpM2B,oBqBqMzBxK,EAAaoM,IAAiB,GAC9B,MACF,QACEpM,EAAaxJ,IAAI,GAIrBoW,GAAQ5M,EAAYE,KA+MhB0H,MAAO+E,GACPlF,QApGe,SAAC1O,EAAMoU,GAC1B,GAAKpE,EAGL,OAFAnB,KAEQ7O,GACN,IrBzT2B,sBGXA,SAACD,EAAMC,GACtCF,EAAiBC,EAAMC,GAEvB,IAAMO,EAAQR,EAAK,GAAGK,OAAS,EACzBI,EAAST,EAAKK,OAAS,EAEzBiU,EAAkB,GActB,IAAK,IAAIpU,KAZTK,EACE,EACA,EACAC,EACAC,EACAa,EAAkBd,EAAOC,GACzB6T,EACAtU,EACAC,GAIYqU,EAAiB,CAC7B,IAAMjV,EAAMiV,EAAgBpU,GAAG,GACzBZ,EAAMgV,EAAgBpU,GAAG,GAC/BF,EAAKX,GAAKC,GAAK0E,OAAO,CAAC/D,KkB8SnB6Q,CAAuB9J,EAAUqN,GACjC,MACF,IrB3TuB,gBqB4TrBvD,EAAsB9J,EAAUqN,GAChC,MACF,KAAKvD,EAAL,MAC2CA,EAAmB9J,GAApD/E,EADV,EACUA,MAAO2B,EADjB,EACiBA,UAAWC,EAD5B,EAC4BA,YjB3SJ,SAAC7D,EAAM4D,EAAWC,EAAY5B,EAAOhC,GACjEF,EAAiBC,EAAMC,GAOvB,IANA,IAAMsU,EAAc,GACdC,EAAY,GACZC,EAAQ,GACRC,EAAU,GAGPrV,EAAM,EAAGA,EAAMW,EAAKK,OAAQhB,IACnC,IAAK,IAAIC,EAAM,EAAGA,EAAMU,EAAKX,GAAKgB,OAAQf,IACxC,IAAID,IAAQuE,EAAUvE,KAAOC,IAAQsE,EAAUtE,OAC3CD,IAAQwE,EAAWxE,KAAOC,IAAQuE,EAAWvE,KAAjD,CACA,IAAM4L,EAAOlL,EAAKX,GAAKC,GACnBuC,EAAOxC,EAAKC,GACdiV,EAAYrJ,GAAQA,EACXtJ,EAAOvC,EAAKC,GACrBmV,EAAMvJ,IAAQ,EACLpJ,EAASzC,EAAKC,IACvBoV,EAAQnV,KAAK2L,GAKnB,IAAMyJ,EAAW,GACX7B,EAAO,GAGT8B,EAAkBhT,EAAOgC,EAAUvE,IAAKuE,EAAUtE,KAClDuV,EAAmBjT,EAAOiC,EAAWxE,IAAKwE,EAAWvE,KACrDwV,GAAgBF,IAAoBC,EAGpCC,EAEFhC,EADkB9S,EAAK,GAAG,KACR,EACT4U,EACT9B,EAAKlP,IAAa,EACTiR,IACT/B,EAAKjP,IAAc,GAIrB,GAAIiR,EAAc,CAAC,IAAD,gBACC7S,EAAMW,QAAQC,IAAI7C,EAAK,GAAG,KAD3B,IAChB,2BAAgD,CAAC,IAAxClB,EAAuC,QAC1C+C,EAAO/C,EAAKO,IAAKP,EAAKQ,MACxBqV,EAASpV,KAAKT,IAHF,oCAMX,GAAI8V,EAAiB,CAAC,IAAD,gBACT3S,EAAMW,QAAQC,IAAIe,IADT,IAC1B,2BAA+C,CAAC,IAAvC9E,EAAsC,QACzC+C,EAAO/C,EAAKO,IAAKP,EAAKQ,MACxBqV,EAASpV,KAAKT,IAHQ,oCAMrB,GAAI+V,EAAkB,CAAC,IAAD,gBACV5S,EAAMW,QAAQC,IAAIgB,IADR,IAC3B,2BAAgD,CAAC,IAAxC/E,EAAuC,QAC1C+C,EAAO/C,EAAKO,IAAKP,EAAKQ,MACxBqV,EAASpV,KAAKT,IAHS,+BAS7B,KAA2B,IAApB6V,EAAStU,QAAc,CAE5B,IAAM0U,EAAYxW,EAAY,EAAGoW,EAAStU,OAAS,GAC7C2U,EAAoBL,EAASI,GAEnCJ,EAASM,OAAOF,EAAW,GAE3B,IAP4B,EAOtBG,EAA0B,GAC5BC,EAAe,EACfC,EAAgB,KATQ,cAYXnT,EAAMW,QAAQC,IAAImS,IAZP,IAY5B,2BAAuD,CAAC,IAA/CvT,EAA8C,QACjDG,EAAOH,EAAKpC,IAAKoC,EAAKnC,OACxB4V,EAAwB3V,KAAKkC,GACvBA,KAAQqR,IACZqC,IACAC,EAAgB3T,KAjBM,8BAuB5B,GAAuC,IAAnCyT,EAAwB7U,QAAiC,IAAjB8U,EAAoB,CAE9DX,EAAUQ,IAAqB,EAC/BT,EAAYS,GAAqB,KAIjClC,EAAKsC,IAAiB,EAPwC,oBAU7CnT,EAAMW,QAAQC,IAAIuS,IAV2B,IAU9D,2BAAmD,CAAC,IAA3CtW,EAA0C,QAC7C+C,EAAO/C,EAAKO,IAAKP,EAAKQ,MACxBqV,EAASpV,KAAKT,IAZ4C,gCAmBlE,cAAmB4V,EAAnB,eAA4B,CAAb,KACNtU,IAAIH,GAGb,cAAiBzC,OAAOuN,OAAOwJ,GAA/B,eAA6C,CAAxC,IAAIc,EAAI,KACC,MAARA,IACAA,KAAQb,GACZa,EAAKjV,IAAIH,KiB4LL6Q,CAAoB9J,EAAUpD,EAAWC,EAAY5B,EAAOoS,GAC5D,MACF,KAAKvD,EAAL,MACqDA,EACjD9J,GADaf,EADjB,EACUhE,MAAqBqT,EAD/B,EACoB1R,UAA2BtG,EAD/C,EACmCuG,YjB7GR,SAAC7D,EAAM4D,EAAWC,EAAY5B,EAAOhC,GACpEF,EAAiBC,EAAMC,GAQvB,IAPA,IAAMsU,EAAc,GACdC,EAAY,GACZC,EAAQ,GACRC,EAAU,GACVa,EAAyB,GAGtBlW,EAAM,EAAGA,EAAMW,EAAKK,OAAQhB,IACnC,IAAK,IAAIC,EAAM,EAAGA,EAAMU,EAAKX,GAAKgB,OAAQf,IACxC,IAAID,IAAQuE,EAAUvE,KAAOC,IAAQsE,EAAUtE,OAC3CD,IAAQwE,EAAWxE,KAAOC,IAAQuE,EAAWvE,KAAjD,CACA,IAAM4L,EAAOlL,EAAKX,GAAKC,GACvB,KAAI4L,KAAQqK,GACZ,GAAIvS,EAAU3D,EAAKC,GAAM,CACvB,IAAMkW,EAAU,IAAIzT,EAAKmJ,EAAMjJ,EAAOsT,GACtChB,EAAYiB,GAAWA,OACdzS,EAAU1D,EAAKC,GACxBmV,EAAMvJ,IAAQ,EACLhI,EAAY7D,EAAKC,IAC1BoV,EAAQnV,KAAK2L,GAKnB,IAAMyJ,EAAW,GACX7B,EAAO,GAGT8B,EAAkB7R,EAAUa,EAAUvE,IAAKuE,EAAUtE,KACrDuV,EAAmB9R,EAAUc,EAAWxE,IAAKwE,EAAWvE,KACxDwV,GAAgBF,IAAoBC,EAGpCC,EAEFhC,EADkB9S,EAAK,GAAG,KACR,EACT4U,EACT9B,EAAKlP,IAAa,EACTiR,IACT/B,EAAKjP,IAAc,GAIrB,GAAIiR,EAAc,CAAC,IAAD,gBACC7S,EAAMW,QAAQC,IAAI7C,EAAK,GAAG,KAD3B,IAChB,2BAAgD,CAAC,IAAxClB,EAAuC,QAC1C+C,EAAO/C,EAAKO,IAAKP,EAAKQ,MACxBqV,EAASpV,KAAK,IAAIwC,EAAKjD,EAAMmD,EAAOsT,KAHxB,sCAMX,GAAIX,EAAiB,CAAC,IAAD,gBACT3S,EAAMW,QAAQC,IAAIe,IADT,IAC1B,2BAA+C,CAAC,IAAvC9E,EAAsC,QACzC+C,EAAO/C,EAAKO,IAAKP,EAAKQ,MACxBqV,EAASpV,KAAK,IAAIwC,EAAKjD,EAAMmD,EAAOsT,KAHd,sCAMrB,GAAIV,EAAkB,CAAC,IAAD,gBACV5S,EAAMW,QAAQC,IAAIgB,IADR,IAC3B,2BAAgD,CAAC,IAAxC/E,EAAuC,QAC1C+C,EAAO/C,EAAKO,IAAKP,EAAKQ,MACxBqV,EAASpV,KAAK,IAAIwC,EAAKjD,EAAMmD,EAAOsT,KAHb,iCAS7B,KAA2B,IAApBZ,EAAStU,QAAc,CAE5B,IAAM0U,EAAYxW,EAAY,EAAGoW,EAAStU,OAAS,GAC7C2U,EAAoBL,EAASI,GAEnCJ,EAASM,OAAOF,EAAW,GAO3B,IALA,IAAMG,EAA0B,GAC5BC,EAAe,EACfC,EAAgB,KAGpB,MAAuB5X,OAAOuN,OAAOiK,EAAkBvS,WAAvD,eAAmE,CAA9D,IAA8D,EAA1DgT,EAAU,KAAgD,cAChDxT,EAAMW,QAAQC,IAAI4S,IAD8B,IACjE,2BAAgD,CAAC,IAAxChU,EAAuC,QAC1CsB,EAAUtB,EAAKpC,IAAKoC,EAAKnC,OAC3B4V,EAAwB3V,KAAKkC,GACvBA,KAAQqR,IACZqC,IACAC,EAAgB3T,KAN2C,iCAanE,GAAuC,IAAnCyT,EAAwB7U,QAAiC,IAAjB8U,EAAoB,CAE9DX,EAAUQ,IAAqB,EAC/BT,EAAYS,GAAqB,KAIjClC,EAAKsC,IAAiB,EAEtB,IAT8D,EASxDM,EAAa,GAT2C,cAY7CzT,EAAMW,QAAQC,IAAIuS,IAZ2B,IAY9D,2BAAmD,CAAC,IAA3CtW,EAA0C,QAC7CA,KAAQ4W,GACR1S,EAAUlE,EAAKO,IAAKP,EAAKQ,MAC3BqV,EAASpV,KAAK,IAAIwC,EAAKjD,EAAMmD,EAAOyT,KAfsB,kCAsBlE,cAAmBhB,EAAnB,eAA4B,CAAb,KACNtU,IAAIH,GAGb,eAAiBzC,OAAOuN,OAAOwJ,GAA/B,gBAA6C,CAAxC,IAAIc,GAAI,MACX,GAAY,MAARA,MACAA,MAAQb,GAEZ,gBAAiBhX,OAAOuN,OAAOsK,GAAK5S,WAApC,kBAAgD,CAA3C,IAAI3D,GAAI,OACPA,KAAS8E,GAAa9E,KAAS+E,GACnC/E,GAAKsB,IAAIH,KiBXP6Q,CAAuB9J,EAAUsO,EAAIhY,EAAG2I,EAAGoO,GAC3C,MACF,SCtVoB,SAACsB,EAAO1V,GAChC,IAAK,IAAIZ,KAAOsW,EACd,IAAK,IAAIrW,KAAOqW,EAAMtW,GAAM,CAC1B,IAAMP,EAAO6W,EAAMtW,GAAKC,GACpBR,EAAKqB,cAAczB,KAAKE,UANT,IAMyCE,EAAKsB,IAAI,CAACH,KDmVpE6Q,CAAgB9J,EAAUqN,KA+E1B9D,oBAAqBC,GACrBzB,cAAeA,GACftC,WAjBU,SAAC/D,GACVuH,IACLS,GAAiB,MACjBjE,EAAW/D,KAePgE,WAAYA,EACZkC,SAAUiC,KAEZ,6BACA,kBAAC+E,GAAA,EAAD,CAAOnW,UAAWP,EAAQuQ,OACxB,iGAGA,wBAAInC,MAAO,CAAE4B,MAAO,QAApB,aAAwC/H,GAAxC,KACA,2BAAI2J,EAAe1J,KAErB,yBACE3H,UAAU,QACV6N,MAAO,CACLuI,iBAAiB,UAAD,OAAY7W,EAAZ,UAChB8W,oBAAoB,UAAD,OAAY7W,EAAZ,YAGpBiT,M,4DElbM6D,I,MARE,SAAC3G,GAChB,IAAM4G,EAAa,CACjB,WACA5G,EAAM6G,KAAO,eAAiB,kBAEhC,OAAO,yBAAKxW,UAAWuW,EAAWtW,KAAK,SCI5BwW,GAAe,SAAC,GAOtB,IANLC,EAMI,EANJA,OACAC,EAKI,EALJA,YACA1I,EAII,EAJJA,MACA2I,EAGI,EAHJA,SACAjJ,EAEI,EAFJA,SAEI,EADJkJ,UAEA,OACE,oCACE,kBAACC,GAAA,EAAD,CACEC,WAAS,EACTC,SAAS,KACTC,KAAMP,EACNQ,QAASP,EACTQ,kBAAgB,0BAEhB,kBAACC,GAAA,EAAD,CAAaxZ,GAAG,0BAA0BqQ,GAC1C,kBAACoJ,GAAA,EAAD,KACE,kBAACC,GAAA,EAAD,KAAoBV,GACnBjJ,GAEH,kBAAC4J,GAAA,EAAD,KACE,kBAACC,GAAA,EAAD,CAAQ1J,QAAS6I,EAAalH,MAAM,aAApC,WAKJ,kBAAC,GAAD,CAAU+G,KAAME,M,4DCbPe,GAtBA,SAAC9H,GACd,OACE,oCACE,yBAAK3P,UAAWP,KAAQgY,QACtB,yBAAKzX,UAAWP,KAAQiY,eACtB,wBAAI1X,UAAWP,KAAQkY,OACrB,wBAAI3X,UAAU,sBAAsB6N,MAAO,CAAE+J,UAAW,SACtD,uBACEC,KAAK,wEACLC,IAAI,sBACJ9X,UAAU,QACV+X,OAAO,UAEP,yBAAKC,IAAKC,KAAQlX,MAdhB,GAckCmX,IAAI,kBCDzCC,GAdQ,WACrB,IR6BwBC,EAAaC,EQ7B/B/J,EAAU,CACdgK,SAAS,WAAD,4BAAE,WAAOC,EAAOC,GAAd,SAAArO,EAAA,6DACRoO,EAAM5Q,UAAY6Q,EAAOhJ,KADjB,+CAEI+I,GAFJ,IAEW5Q,UAAW6Q,EAAOhJ,QAF7B,2CAAF,qDAAC,GAITiJ,SAAS,WAAD,4BAAE,WAAOF,EAAOC,GAAd,SAAArO,EAAA,6DACRoO,EAAMhJ,KAAOiJ,EAAOjJ,KADZ,+CAEIgJ,GAFJ,IAEWhJ,KAAMiJ,EAAOjJ,QAFxB,2CAAF,qDAAC,IRwBa6I,EQnBd9J,GRmB2B+J,EQnBlB,CAAE1Q,U1BbC,W0BawB4H,K1BbxB,ekBkCpBnB,GAAW,6BAAQA,IAAgBiK,IAGrC/J,GAAO,6BAAQA,IAAY8J,I,oBS3B7BM,KAEA,IAAM5I,GAAYC,aAAW,CAC3BC,MAAO,CACLC,QAAS,MACTC,OAAQ,OACRnP,MAAO,SACPoP,UAAW,OACXC,aAAc,QAEhBH,QAAS,CACPA,QAAS,SA+DE0I,OA3Df,WAAgB,IAAD,EACe5L,oBAAS,GADxB,mBACN2J,EADM,KACEkC,EADF,OAEmB7L,mBAAS,MAF5B,mBAEN8L,EAFM,KAEIC,EAFJ,OAGGvK,KAATgK,EAHM,oBAIP9Y,EAAUqQ,KAEhBpQ,qBAAU,YACS,uCAAG,kCAAAyK,EAAA,sEACC,MAAO,YAAUoO,EAAMhJ,KAAvB,QADD,cACZA,EADY,gBAEAwJ,MAAMxJ,EAAKyJ,SAFX,cAEZC,EAFY,gBAGCA,EAAIC,OAHL,OAGZA,EAHY,OAIZL,EAAWM,KAAOD,GACxBJ,EAAYD,GALM,4CAAH,qDAOjBO,KACC,CAACb,EAAMhJ,OAEV7P,qBAAU,WACR2Z,MACC,IAEH,IAAMA,EAAmB,WACvBT,GAAU,IAOZ,OACE,oCACE,yBAAK5Y,UAAWsZ,KAAOX,KACrB,kBAAC,GAAD,CAAOvJ,WAAYiK,IACnB,kBAAClD,GAAA,EAAD,CAAOnW,UAAWP,EAAQuQ,MAAOuJ,UAAW,IAC1C,yBAAKC,wBAAyB,CAAEC,OAAQZ,OAI5C,kBAAC,GAAD,CACE5K,MAAM,GACNyI,OAAQA,EACRC,YAhBoB,WACxBiC,GAAU,IAgBN5Y,UAAWsZ,KAAOI,cAElB,2EACA,6BACA,sMAKA,wFAGF,kBAAC,GAAD,Q,MC3ENC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,GAAD,OAEF9V,SAASgD,eAAe,W","file":"static/js/main.e70c5424.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"Footer\":\"Footer_Footer__238hM\",\"Icons\":\"Footer_Icons__3PTSJ\",\"IconContainer\":\"Footer_IconContainer__2erq5\",\"FooterTitle\":\"Footer_FooterTitle__1Ygxr\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"NavigationItem\":\"NavigationItem_NavigationItem__2SpXc\",\"Btn\":\"NavigationItem_Btn__3xhRr\",\"navbar\":\"NavigationItem_navbar__2rE4b\",\"NavigationItem-content\":\"NavigationItem_NavigationItem-content__2c_Zw\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"App\":\"App_App__16ZpL\",\"Container\":\"App_Container__10KOh\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Toolbar\":\"Toolbar_Toolbar__ApScI\"};","module.exports = \"data:image/png;base64,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\"","var map = {\n\t\"./A*.md\": [\n\t\t76,\n\t\t3\n\t],\n\t\"./Bellman-Ford.md\": [\n\t\t77,\n\t\t4\n\t],\n\t\"./Bidirectional BFS.md\": [\n\t\t78,\n\t\t5\n\t],\n\t\"./Breadth First Search.md\": [\n\t\t79,\n\t\t6\n\t],\n\t\"./Contour Walls.md\": [\n\t\t80,\n\t\t7\n\t],\n\t\"./D*.md\": [\n\t\t81,\n\t\t8\n\t],\n\t\"./Depth First Search.md\": [\n\t\t82,\n\t\t9\n\t],\n\t\"./Dijkstra.md\": [\n\t\t83,\n\t\t10\n\t],\n\t\"./Floyd-Warshall.md\": [\n\t\t84,\n\t\t11\n\t],\n\t\"./Greedy Best First Search.md\": [\n\t\t85,\n\t\t12\n\t],\n\t\"./Kruskal's Algorithm.md\": [\n\t\t86,\n\t\t13\n\t],\n\t\"./Prim's Algorithm.md\": [\n\t\t87,\n\t\t14\n\t],\n\t\"./Prim'sMazeAlgo.md\": [\n\t\t88,\n\t\t15\n\t],\n\t\"./Random Maze.md\": [\n\t\t89,\n\t\t16\n\t],\n\t\"./Recursive Division.md\": [\n\t\t90,\n\t\t17\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(function() {\n\t\treturn __webpack_require__.t(id, 7);\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 72;\nmodule.exports = webpackAsyncContext;","/* Algorithm Constants */\nexport const DIJKSTRA = \"Dijkstra\"\nexport const ASTAR = \"A*\"\nexport const GREEDY_BFS = \"Greedy Best First Search\"\nexport const BFS = \"Breadth First Search\"\nexport const DFS = \"Depth First Search\"\nexport const PRIMS = \"Prim's Algorithm\"\nexport const DSTAR = \"D*\"\nexport const KRUSKAL = \"Kruskal's Algorithm\"\nexport const FLOYD_WARSHALL = \"Floyd-Warshall\"\nexport const BELLMAN_FORD = \"Bellman-Ford\"\nexport const BIDIRECTIONAL_BFS = \"Bidirectional BFS\"\n\n/* Maze Generator Constants */\nexport const RAND_MAZE = \"Random Maze\"\nexport const RECURSIVE_DIVISON = \"Recursive Division\"\nexport const DRAW_COUNTOUR = \"Contour Walls\"\nexport const PRIMS_ALGO = \"Prim's Maze Generator\"\nexport const PRIMS_ALGO_531 = \"Prim's Maze Generator (5,1,3)\"\n\n/* Board State Constants */\nexport const ADDING_WEIGHT = \"Adding Weight\"\nexport const MOVING_TARGET = \"Moving Target\"\nexport const ADDING_N_WEIGHT = \"Adding N Weight\"\nexport const MOVING_START = \"Moving Start\"\nexport const MOVING_SECOND_TARGET = \"Moving Second Target\"\nexport const SETTING_SECOND_TARGET = \"Moving Second Target\"\nexport const DELETING = \"Deleting\"\nexport const PLACING_WALLS = \"Placing Walls\"\nexport const VISUALIZING = \"Visualizing\"\n\n/* Board Element Constants */\nexport const CELL = \"Cell\"\nexport const WALL = \"Wall\"\nexport const WEIGHT = \"Weight\"\nexport const START = \"Start\"\nexport const TARGET = \"Target\"\nexport const N_WEIGHT = \"NegativeWeight\"\nexport const SHORTEST_PATH = \"ShortestPath\"\nexport const SEARCHED = \"Searched\"\nexport const SEARCHED_2 = \"Searched2\"\nexport const SEARCHED_DONE = \"Searched2Done\"\nexport const SECONDARY_TARGET = \"SecondaryTarget\"\n\n/* Algorithm Introduction Constants */\nexport const ALG_TITLE = {}\nALG_TITLE[DIJKSTRA] = \"Dijkstra's Algorithm is a weighted algorithm that guarantees the shortest path\"\nALG_TITLE[ASTAR] = \"A* Algorithm is a weighted algorithm that guarantees the shortest path\"\nALG_TITLE[GREEDY_BFS] = \"Greedy BFS Algorithm is a weighted algorithm that does not guarantee the shortest path\"\nALG_TITLE[FLOYD_WARSHALL] = \"Floyd-Warshall algorithm is a weighted algorithm that guarantees to find the minimum distance between ANY two nodes\"\nALG_TITLE[BFS] = \"BFS is an un-weighted algorithm, it guarantees the shortest path in an unweighted graph but not in a weighted one\"\nALG_TITLE[DFS] = \"DFS is an un-weighted algorithm with the purpose of traversing a graph, shortest path/distance is NOT guaranteed\"\nALG_TITLE[PRIMS] = \"Prim's algorithm is used to find the Minimum Spanning Tree of a weighted Graph, shortest path/distance is NOT guaranteed\"\nALG_TITLE[KRUSKAL] = \"Kruskal's algorithm is used to find the Minimum Spanning Tree of a weighted Graph, shortest path/distance is NOT guaranteed\"\n\n/* Miscellaneous */\nexport const HORIZONTAL = \"horizontal\";\nexport const VERTICAL = \"vertical\";\nexport const UNK = \"Unknown\";\n\n/**\n * Generate a random integer between a range [min, max] (inclusive).\n * Extracted from : https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript\n * @param {number} min must be less than max\n * @param {number} max must be greater than min\n */\nexport const randBetween = (min, max) => {\n    // min and max included\n    return Math.floor(Math.random() * (max - min + 1) + min);\n  };","import React, { useEffect } from \"react\";\nimport * as cts from \"../../utility/constants\";\nimport \"./Cell.css\";\n\nconst Cell = ({ node, mouse, numRows, numCols }) => {\n  let classes = [cts.CELL];\n  let icon = null;\n\n  useEffect(() => node.setClasses(), [node]);\n\n  if (\n    node.row === Math.floor(numRows / 2) &&\n    node.col === Math.floor((numCols * 1) / 3)\n  ) {\n    classes.push(cts.START);\n  }\n  if (\n    node.row === Math.floor(numRows / 2) &&\n    node.col === Math.floor((numCols * 2) / 3)\n  ) {\n    classes.push(cts.TARGET);\n  }\n\n  return (\n    <div\n      className={classes.join(\" \")}\n      id={`${node.row} ${node.col}`}\n      onMouseDown={() => mouse.onMouseDown(node)}\n      onMouseEnter={() => mouse.onMouseEnter(node)}\n      onMouseLeave={() => mouse.onMouseLeave(node)}\n      onMouseUp={() => mouse.onMouseUp(node)}\n    >\n      {icon}\n    </div>\n  );\n};\n\nexport default Cell;\n","export const drawContourWalls = (grid, type) => {\n  for (let i in grid) {\n    if (!grid[i][0].isKeyValue()) {\n      grid[i][0].add(type);\n    }\n\n    if (!grid[i][grid[i].length - 1].isKeyValue()) {\n      grid[i][grid[i].length - 1].add(type);\n    }\n  }\n\n  for (let j in grid[0]) {\n    if (!grid[0][j].isKeyValue()) {\n      grid[0][j].add(type);\n    }\n\n    if (!grid[grid.length - 1][j].isKeyValue()) {\n      grid[grid.length - 1][j].add(type);\n    }\n  }\n};\n","import { drawContourWalls } from \"./Contour\";\nimport * as cts from \"../constants\";\nimport { randBetween } from \"../constants\";\n\nexport const recursiveDivision = (grid, type) => {\n  drawContourWalls(grid, type);\n  // Subtract 2 accounting for drawn contour\n  const width = grid[0].length - 2;\n  const height = grid.length - 2;\n  // An array that contains the nodes that would clot the maze\n  let prohibitedCells = [];\n\n  divide(\n    1,\n    1,\n    width,\n    height,\n    chooseOrientation(width, height),\n    prohibitedCells,\n    grid,\n    type\n  );\n\n  // Remove prohibited cells so that all of the board is reachable\n  for (let i in prohibitedCells) {\n    const row = prohibitedCells[i][0];\n    const col = prohibitedCells[i][1];\n    grid[row][col].remove([type]);\n  }\n};\n\n/**\n * Perform a single division on an input grid.\n *\n * @param {number} row - top left corner row\n * @param {number} col - top left corner column\n * @param {number} width - width of the grid (inclusive)\n * @param {number} height - height of the grid (inclusive)\n * @param {string} orientation - the orientation to split the grid\n * @param {Node[]} prohibited - array that holds the cells that are restricted,\n * used to avoid clots.\n * @param {Node[][]} grid - inputGrid\n * @param {*} type - the type of division (Walls or Weight)\n */\nconst divide = (\n  row,\n  col,\n  width,\n  height,\n  orientation,\n  prohibited,\n  grid,\n  type\n) => {\n  if (width <= 2 || height <= 2) return;\n\n  // Is the wall to be drawn horizontal?\n  const isCutHorizontal = orientation === cts.HORIZONTAL;\n\n  // Where will the wall be drawn from?\n  let whereCol = col + (isCutHorizontal ? 0 : randBetween(2, width - 2)); // Rand number between the col and width\n  let whereRow = row + (isCutHorizontal ? randBetween(2, height - 2) : 0); // Rand number between the row and height\n\n  // Where will the passage through the wall exist?\n  const passCol = whereCol + (isCutHorizontal ? randBetween(0, width - 1) : 0); // Rand number between the col and width\n\n  const passRow = whereRow + (isCutHorizontal ? 0 : randBetween(0, height - 1)); // Rand number between the row and height\n\n  // How long will the wall be?\n  const length = isCutHorizontal ? width : height;\n\n  // Draw the walls\n  drawWall(whereRow, whereCol, isCutHorizontal, length, grid, type);\n  updateProhibitedCells(passRow, passCol, isCutHorizontal, prohibited);\n\n  // get first recursive call data\n  let newWidth = isCutHorizontal ? width : whereCol - col;\n  let newHeight = isCutHorizontal ? whereRow - row : height;\n  let newOrientation = chooseOrientation(newWidth, newHeight);\n\n  divide(row, col, newWidth, newHeight, newOrientation, prohibited, grid, type);\n\n  // get second recursive call data\n  let newCol = isCutHorizontal ? col : whereCol + 1;\n  let newRow = isCutHorizontal ? whereRow + 1 : row;\n\n  newWidth = isCutHorizontal ? width : col + width - whereCol - 1;\n  newHeight = isCutHorizontal ? row + height - whereRow - 1 : height;\n  newOrientation = chooseOrientation(newWidth, newHeight);\n\n  divide(\n    newRow,\n    newCol,\n    newWidth,\n    newHeight,\n    newOrientation,\n    prohibited,\n    grid,\n    type\n  );\n};\n\n/**\n * Draw a wall on the grid\n * @param {number} startRow\n * @param {number} startCol\n * @param {boolean} isCutHorizontal\n * @param {number} length - The length of the wall\n * @param {Node[][]} grid - Reference to the Node Grid\n * @param {string} type - Type of impediment to draw: Wall or Weight\n */\nconst drawWall = (startRow, startCol, isCutHorizontal, length, grid, type) => {\n  for (let i = 0; i < length; i++) {\n    const row = startRow + (isCutHorizontal ? 0 : i);\n    const col = startCol + (isCutHorizontal ? i : 0);\n\n    const cell = grid[row][col];\n    if (!cell.isKeyValue()) cell.add([type]);\n  }\n};\n\n/**\n * Helper Method that determines if the cut should be horizontal or vertical\n * based on the input dimensions.\n * If the width is less than the height return horizontal else vertical.\n * @param {number} width\n * @param {number} height\n */\nconst chooseOrientation = (width, height) => {\n  if (width < height) return cts.HORIZONTAL;\n  return cts.VERTICAL;\n};\n\nconst updateProhibitedCells = (row, col, horizontal, prohibited) => {\n  prohibited.push([row, col]);\n  if (!horizontal) {\n    prohibited.push([row, col + 1]);\n    prohibited.push([row, col - 1]);\n  } else {\n    prohibited.push([row + 1, col]);\n    prohibited.push([row - 1, col]);\n  }\n};\n","import { drawContourWalls } from \"./Contour\";\nimport { randBetween } from \"../constants\";\n\n/**\n * TODO Make prims algorithm maze gen function more flexible allowing for various types of grids\n */\n\n/**\n * Lookup Table for a (5, 3, 1) Grid coloring\n */\nconst lookupTable531 = [\n  [0, 1, 2, 3, 4, 0],\n  [3, 4, 0, 1, 2, 3],\n  [1, 2, 3, 4, 0, 1],\n  [4, 0, 1, 2, 3, 4],\n  [2, 3, 4, 0, 1, 2],\n  [0, 1, 2, 3, 4, 0],\n];\n\n/** \n * Color codes\n */\nconst DARK_BLUE = 0;\nconst LIGHT_YELLOW = 1;\nconst DARK_YELLOW = 2;\nconst LIGHT_BLUE = 3;\nconst WHITE = 4;\n\n/**\n * Generate a Random Maze Using Prim's Algorithm on a (2,0,2) Colored Grid\n * @param {Node[][]} grid\n * @param {Node} startNode\n * @param {Node} targetNode\n * @param {Graph} graph\n * @param {string} type\n */\nexport const primsAlgorithm = (grid, startNode, targetNode, graph, type) => {\n  drawContourWalls(grid, type);\n  const closedWalls = {};\n  const openWalls = {};\n  const rooms = {};\n  const pillars = [];\n\n  // Mark all walls as closed\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      if (row === startNode.row && col === startNode.col) continue;\n      if (row === targetNode.row && col === targetNode.col) continue;\n      const curr = grid[row][col];\n      if (isWall(row, col)) {\n        closedWalls[curr] = curr;\n      } else if (isRoom(row, col)) {\n        rooms[curr] = true;\n      } else if (isPillar(row, col)) {\n        pillars.push(curr);\n      }\n    }\n  }\n\n  const wallList = [];\n  const path = {};\n\n  // Add startNode and targetNode to the path\n  let isStartNodeRoom = isRoom(startNode.row, startNode.col);\n  let isTargetNodeRoom = isRoom(targetNode.row, targetNode.col);\n  let neitherRooms = !isStartNodeRoom && !isTargetNodeRoom;\n\n  // If neither StartNode nor TargetNode is a room add a default room\n  if (neitherRooms) {\n    const firstRoom = grid[1][1];\n    path[firstRoom] = true;\n  } else if (isStartNodeRoom) {\n    path[startNode] = true;\n  } else if (isTargetNodeRoom) {\n    path[targetNode] = true;\n  }\n\n  // Add The Adjacent walls of the room to the wall list\n  if (neitherRooms) {\n    for (let node of graph.AdjList.get(grid[1][1])) {\n      if (isWall(node.row, node.col)) {\n        wallList.push(node);\n      }\n    }\n  } else if (isStartNodeRoom) {\n    for (let node of graph.AdjList.get(startNode)) {\n      if (isWall(node.row, node.col)) {\n        wallList.push(node);\n      }\n    }\n  } else if (isTargetNodeRoom) {\n    for (let node of graph.AdjList.get(targetNode)) {\n      if (isWall(node.row, node.col)) {\n        wallList.push(node);\n      }\n    }\n  }\n\n  // While the Wall List is not empty\n  while (wallList.length !== 0) {\n    // Select a wall from the list\n    const randIndex = randBetween(0, wallList.length - 1);\n    const currentRandomWall = wallList[randIndex];\n    // Remove the wall from the wall list\n    wallList.splice(randIndex, 1);\n\n    const roomsAdjacentToCurrWall = [];\n    let numNotInPath = 0;\n    let unvisitedRoom = null;\n\n    // Find the rooms adjacent to the wall.\n    for (let cell of graph.AdjList.get(currentRandomWall)) {\n      if (isRoom(cell.row, cell.col)) {\n        roomsAdjacentToCurrWall.push(cell);\n        if (!(cell in path)) {\n          numNotInPath++;\n          unvisitedRoom = cell;\n        }\n      }\n    }\n\n    // If there are two adjacent rooms, and only one of them is not in path\n    if (roomsAdjacentToCurrWall.length === 2 && numNotInPath === 1) {\n      // Mark the wall as open\n      openWalls[currentRandomWall] = true;\n      closedWalls[currentRandomWall] = null;\n      // delete closedWalls.currentRandomWall;\n\n      // Add the unvisited room to the path\n      path[unvisitedRoom] = true;\n\n      // Add the walls adjacent to the unvisited room to the wall list\n      for (let node of graph.AdjList.get(unvisitedRoom)) {\n        if (isWall(node.row, node.col)) {\n          wallList.push(node);\n        }\n      }\n    }\n  }\n\n  // Finally Add the Walls\n  for (let pillar of pillars) {\n    pillar.add(type);\n  }\n\n  for (let wall of Object.values(closedWalls)) {\n    if (wall == null) continue;\n    if (wall in openWalls) continue;\n    wall.add(type);\n  }\n};\n\n/**\n * Returns true if the input location is initially a room\n * @param {number} row\n * @param {number} col\n */\nconst isRoom = (row, col) => {\n  return row % 2 !== 0 && col % 2 !== 0;\n};\n\n/**\n * Returns true if the input location is initially a wall\n * @param {number} row\n * @param {number} col\n */\nconst isWall = (row, col) => {\n  if (row % 2 === 0) {\n    return col % 2 !== 0;\n  }\n  return col % 2 === 0;\n};\n\n/**\n * Returns true if the input location is a pillar\n * @param {number} row\n * @param {number} col\n */\nconst isPillar = (row, col) => {\n  return row % 2 === 0 && col % 2 === 0;\n};\n\nclass Wall {\n  matches = {\n    0: LIGHT_BLUE,\n    1: DARK_YELLOW,\n    2: LIGHT_YELLOW,\n    3: DARK_BLUE,\n  };\n\n  /**\n   * Add adjacent Nodes that are part of the wall\n   * @param {Node} wallNode\n   * @param {Graph} graph\n   * @param {string} color\n   */\n  constructor(wallNode, graph, set) {\n    this.locations = {};\n    const colorMatch = this.matches[\n      getColorCode(wallNode.row, wallNode.col, lookupTable531)\n    ];\n    this.locations[wallNode] = wallNode;\n    set[wallNode] = true;\n\n    for (let node of graph.AdjList.get(wallNode)) {\n      let c = getColorCode(node.row, node.col, lookupTable531);\n      if (c === colorMatch) {\n        this.locations[node] = node;\n        set[node] = true;\n      }\n    }\n  }\n\n  toString() {\n    let out = \"\";\n    for (let location of Object.keys(this.locations)) {\n      out += location;\n    }\n    return \"[\" + out + \"]\";\n  }\n}\n\n/**\n * Generate a Random Maze Using Prim's Algorithm on a (5,3,1) Colored Grid\n * @param {Node[][]} grid\n * @param {Node} startNode\n * @param {Node} targetNode\n * @param {Graph} graph\n * @param {string} type\n */\nexport const primsAlgorithm531 = (grid, startNode, targetNode, graph, type) => {\n  drawContourWalls(grid, type);\n  const closedWalls = {};\n  const openWalls = {};\n  const rooms = {};\n  const pillars = [];\n  const nodesConsideredAsWalls = {};\n\n  // Mark all walls as closed\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      if (row === startNode.row && col === startNode.col) continue;\n      if (row === targetNode.row && col === targetNode.col) continue;\n      const curr = grid[row][col];\n      if (curr in nodesConsideredAsWalls) continue;\n      if (isWall531(row, col)) {\n        const newWall = new Wall(curr, graph, nodesConsideredAsWalls);\n        closedWalls[newWall] = newWall;\n      } else if (isRoom531(row, col)) {\n        rooms[curr] = true;\n      } else if (isPillar531(row, col)) {\n        pillars.push(curr);\n      }\n    }\n  }\n\n  const wallList = [];\n  const path = {};\n\n  // Add startNode and targetNode to the path\n  let isStartNodeRoom = isRoom531(startNode.row, startNode.col);\n  let isTargetNodeRoom = isRoom531(targetNode.row, targetNode.col);\n  let neitherRooms = !isStartNodeRoom && !isTargetNodeRoom;\n\n  // If neither StartNode nor TargetNode is a room add a default room\n  if (neitherRooms) {\n    const firstRoom = grid[1][1];\n    path[firstRoom] = true;\n  } else if (isStartNodeRoom) {\n    path[startNode] = true;\n  } else if (isTargetNodeRoom) {\n    path[targetNode] = true;\n  }\n\n  // Add The Adjacent walls of the room to the wall list\n  if (neitherRooms) {\n    for (let node of graph.AdjList.get(grid[1][1])) {\n      if (isWall(node.row, node.col)) {\n        wallList.push(new Wall(node, graph, nodesConsideredAsWalls));\n      }\n    }\n  } else if (isStartNodeRoom) {\n    for (let node of graph.AdjList.get(startNode)) {\n      if (isWall(node.row, node.col)) {\n        wallList.push(new Wall(node, graph, nodesConsideredAsWalls));\n      }\n    }\n  } else if (isTargetNodeRoom) {\n    for (let node of graph.AdjList.get(targetNode)) {\n      if (isWall(node.row, node.col)) {\n        wallList.push(new Wall(node, graph, nodesConsideredAsWalls));\n      }\n    }\n  }\n\n  // While the Wall List is not empty\n  while (wallList.length !== 0) {\n    // Select a wall from the list\n    const randIndex = randBetween(0, wallList.length - 1);\n    const currentRandomWall = wallList[randIndex];\n    // Remove the wall from the wall list\n    wallList.splice(randIndex, 1);\n\n    const roomsAdjacentToCurrWall = [];\n    let numNotInPath = 0;\n    let unvisitedRoom = null;\n\n    // Find the rooms adjacent to the wall.\n    for (let cellInWall of Object.values(currentRandomWall.locations)) {\n      for (let cell of graph.AdjList.get(cellInWall)) {\n        if (isRoom531(cell.row, cell.col)) {\n          roomsAdjacentToCurrWall.push(cell);\n          if (!(cell in path)) {\n            numNotInPath++;\n            unvisitedRoom = cell;\n          }\n        }\n      }\n    }\n\n    // If there are two adjacent rooms, and only one of them is not in path\n    if (roomsAdjacentToCurrWall.length === 2 && numNotInPath === 1) {\n      // Mark the wall as open\n      openWalls[currentRandomWall] = true;\n      closedWalls[currentRandomWall] = null;\n      // delete closedWalls.currentRandomWall;\n\n      // Add the unvisited room to the path\n      path[unvisitedRoom] = true;\n\n      const addedWalls = {};\n\n      // Add the walls adjacent to the unvisited room to the wall list\n      for (let node of graph.AdjList.get(unvisitedRoom)) {\n        if (node in addedWalls) continue;\n        if (isWall531(node.row, node.col)) {\n          wallList.push(new Wall(node, graph, addedWalls));\n        }\n      }\n    }\n  }\n\n  // Finally Add the Walls\n  for (let pillar of pillars) {\n    pillar.add(type);\n  }\n\n  for (let wall of Object.values(closedWalls)) {\n    if (wall == null) continue;\n    if (wall in openWalls) continue;\n\n    for (let node of Object.values(wall.locations)) {\n      if (node === startNode || node === targetNode) continue;\n      node.add(type);\n    }\n  }\n};\n\nconst isRoom531 = (row, col) => {\n  return getColorCode(row, col, lookupTable531) === WHITE;\n};\n\nconst isWall531 = (row, col) => {\n  const colorCode = getColorCode(row, col, lookupTable531);\n  return (\n    colorCode === DARK_YELLOW ||\n    colorCode === LIGHT_YELLOW ||\n    colorCode === LIGHT_BLUE ||\n    colorCode === DARK_BLUE\n  );\n};\n\nconst isPillar531 = (row, col) => {\n  return false;\n};\n\nconst getColorCode = (row, col, lookupTable) => {\n  const m = lookupTable[0].length - 1;\n  const n = lookupTable.length - 1;\n  const lookupColor = lookupTable[row % n][col % m];\n  return lookupColor;\n};\n\n/* References : https://www.gamasutra.com/blogs/HermanTulleken/20161005/282629/Algorithms_for_making_more_interesting_mazes.php */","import { Graph } from \"./index\";\nimport * as cts from \"./constants\";\n\nexport const calculateNumVertices = () => {\n  const numCells = document.getElementsByClassName(cts.CELL).length;\n  const numWalls = document.getElementsByClassName(cts.WALL).length;\n  return numCells - numWalls;\n};\n\nexport const generateNodeGrid = (grid) => {\n  const nodesGrid = [];\n  const graph = new Graph(calculateNumVertices());\n\n  for (let row in grid) {\n    nodesGrid[row] = [];\n    for (let col in grid[row]) {\n      graph.addVertex(grid[row][col]);\n    }\n  }\n  return graph;\n};\n\nexport const getKeyNodes = (nodesGrid) => {\n  let startNode = null;\n  let targetNode = null;\n\n  for (let row = 0; row < nodesGrid.length; row++) {\n    for (let col = 0; col < nodesGrid[row].length; col++) {\n      const currentNode = nodesGrid[row][col];\n      if (currentNode.is(cts.SHORTEST_PATH)) {\n        currentNode.remove([cts.SHORTEST_PATH]);\n        currentNode.add(cts.SEARCHED_DONE);\n      }\n      if (currentNode.is(cts.START)) startNode = currentNode;\n      if (currentNode.is(cts.TARGET)) targetNode = currentNode;\n    }\n  }\n  return { startNode, targetNode };\n};\n\nexport const generateGraph = (nodesGrid) => {\n  let startNode = null;\n  let targetNode = null;\n\n  const graph = generateNodeGrid(nodesGrid);\n\n  for (let row = 0; row < nodesGrid.length; row++) {\n    for (let col = 0; col < nodesGrid[row].length; col++) {\n      const currentNode = nodesGrid[row][col];\n\n      if (!currentNode.is(cts.WALL)) {\n        if (currentNode.is(cts.START)) startNode = currentNode;\n        if (currentNode.is(cts.TARGET)) targetNode = currentNode;\n        const neighbors = currentNode.getNeighbors(nodesGrid);\n\n        for (let i in neighbors) {\n          graph.addEdge(currentNode, neighbors[i]);\n        }\n      }\n    }\n  }\n  if (startNode) startNode.dist = 0;\n  return { graph, startNode, targetNode };\n};\n","export class Queue {\n  constructor() {\n    this.items = [];\n  }\n\n  enqueue(element) {\n    this.items.push(element);\n  }\n\n  dequeue() {\n    if (this.isEmpty()) return \"Underflow\";\n    return this.items.shift();\n  }\n\n  front() {\n    if (this.isEmpty()) return \"No elements in Queue\";\n    return this.items[0];\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  printQueue() {\n    var str = \"\";\n    for (var i = 0; i < this.items.length; i++) str += this.items[i] + \" \";\n    return str;\n  }\n\n  size() {\n    return this.items.length;\n  }\n}\n","/*\n    Disjoing set data structure (Array representation).\n\n    1. Initially instantiate the array with the number of vertices in the graph. Fill the array\n    with -1, this indicates that each vertices is a set with itself as a parent.\n\n    Performing a union\n    set the parent of one set to point at the parent of the second set and adjust \n    the new parent weight.\n*/\n\nexport class DisjointSet {\n  constructor(length) {\n    this.items = new Array(length).fill(-1);\n  }\n\n  setParent = (child, parent) => {\n    const weight = this.getWeight(child);\n    this.items[child] = parent;\n    this.items[parent] += weight;\n  };\n\n  getWeight = (num) => this.items[num];\n\n  findParent = (num) => {\n    if (this.items[num] < 0) return num;\n    return this.findParent(this.items[num]);\n  };\n\n  // If there exists a cycle return true\n  // else unite the graph and return false\n  hasCycle = (v1, v2) => {\n    const p1 = this.findParent(v1);\n    const p2 = this.findParent(v2);\n    if (p1 === p2 && p1 > 0) return true;\n    this.union(p1, p2);\n    return false;\n  };\n\n  // Takes two parent nodes and merges them to\n  // creates one set\n  union(parent1, parent2) {\n    const p1Weight = this.getWeight(parent1);\n    const p2Weight = this.getWeight(parent2);\n    p1Weight <= p2Weight\n      ? this.setParent(parent2, parent1)\n      : this.setParent(parent1, parent2);\n  }\n}\n","import * as cts from \"./constants\";\n\n/**\n * Node class defines the properties and behaviour of a vertex in the graph\n */\nexport default class Node {\n  /**\n   * Each Node is initialized with a row, column and id\n   * @param {Number} row\n   * @param {Number} col\n   * @param {Number} id\n   */\n  constructor(row, col, id) {\n    this.row = row;\n    this.col = col;\n    this.id = id;\n    this.predecessor = null;\n    this.dist = Infinity;\n    this.g = 1;\n    this.h = null;\n    this.f = Infinity;\n  }\n\n  /**\n   * Returns a list of neighbors for the node\n   * @param {Node[][]} grid\n   * @returns {Number[]} neighbors\n   */\n  getNeighbors(grid) {\n    const cellNotInGraph = (row, col) => {\n      return grid[row][col].is(cts.WALL);\n    };\n\n    if (this.is(cts.WALL)) return [];\n    let neighbors = [];\n\n    if (this.row > 0 && !cellNotInGraph(this.row - 1, this.col)) {\n      // N\n      neighbors.push(grid[this.row - 1][this.col]);\n    }\n    if (this.col > 0 && !cellNotInGraph(this.row, this.col - 1)) {\n      // W\n      neighbors.push(grid[this.row][this.col - 1]);\n    }\n    if (this.row < grid.length - 1 && !cellNotInGraph(this.row + 1, this.col)) {\n      // S\n      neighbors.push(grid[this.row + 1][this.col]);\n    }\n    if (\n      this.col < grid[this.row].length - 1 &&\n      !cellNotInGraph(this.row, this.col + 1)\n    ) {\n      // E\n      neighbors.push(grid[this.row][this.col + 1]);\n    }\n\n    return neighbors;\n  }\n\n  /**\n   * Returns true if the input Node is a neighbor to the node\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  isNeighbor(node) {\n    // O(1)\n    if (this.row === node.row)\n      return this.col + 1 === node.col || this.col - 1 === node.col;\n    if (this.col === node.col)\n      return this.row + 1 === node.row || this.row - 1 === node.row;\n    return false;\n  }\n\n  /**\n   * Returns a distance to input node\n   * @param {Node} end\n   */\n  getDistanceTo(end) {\n    if (this === end) return 0;\n    if (!this.isNeighbor(end)) return Infinity;\n    return end.getWeight();\n  }\n\n  /**\n   * Get weight of current Node\n   */\n  getWeight() {\n    if (this.is(cts.WEIGHT)) return 15;\n    if (this.is(cts.WALL)) return Infinity;\n    if (this.is(cts.N_WEIGHT)) return -1;\n    return 1;\n  }\n  /**\n   * Remove a CSS class from the Node\n   * @param {string} s\n   */\n  removeClass(s) {\n    this.classes.remove(s);\n  }\n\n  /**\n   * Initialize the Node classes\n   */\n  setClasses() {\n    this.cell = document.getElementById(`${this.row} ${this.col}`);\n    this.classes = this.cell.classList;\n  }\n\n  /**\n   * Return string representation of Node: (row, col)\n   */\n  toString() {\n    return \"(\" + this.row + \" \" + this.col + \")\";\n  }\n\n  /**\n   * Sets the Node as a Wall\n   */\n  setWall() {\n    if (this.isKeyValue()) return;\n    this.remove([cts.SEARCHED, cts.SEARCHED_2]);\n    this.add(cts.WALL);\n  }\n\n  /**\n   * Assign the Node as the Target Node\n   */\n  setAsTarget() {\n    this.add(cts.TARGET);\n    this.markShortestPath();\n  }\n\n  /**\n   * Assign the Node as the Second Target\n   */\n  setAsSecondTarget() {\n    this.remove(cts.WALL);\n    this.add(cts.SECONDARY_TARGET);\n  }\n\n  /**\n   * Mark the Node as searched by adding cts.SEARCHED CSS class\n   */\n  markSearched() {\n    if (this.is(cts.TARGET)) return;\n    this.add(cts.SEARCHED);\n  }\n\n  /**\n   * Mark the Node as searched by adding cts.SEARCHED_2 CSS class\n   */\n  markSearched2() {\n    if (this.is(cts.TARGET)) return;\n    this.add(cts.SEARCHED_2);\n  }\n\n  /**\n   * Mark the Node as searched by adding Searched2Done CSS class\n   */\n  markSearched2Done() {\n    if (this.is(cts.TARGET) || this.is(cts.START)) return;\n    this.add(cts.SEARCHED_DONE);\n  }\n\n  /**\n   * Remove CSS classes that have visuals\n   */\n  removeVisuals() {\n    this.remove([cts.SHORTEST_PATH, cts.SEARCHED, cts.SEARCHED_2, cts.SEARCHED_DONE]);\n    this.predecessor = null;\n    this.dist = Infinity;\n  }\n\n  /**\n   * Remove all CSS classes for the Node except cts.CELL, cts.WALL and cts.WEIGHT\n   */\n  removeClasses() {\n    this.classes.forEach(\n      (item) =>\n        item !== cts.CELL &&\n        item !== cts.WALL &&\n        item !== cts.WEIGHT &&\n        item !== cts.N_WEIGHT &&\n        this.classes.remove(item)\n    );\n  }\n\n  reset() {\n    this.remove([cts.SHORTEST_PATH, cts.WALL, cts.SEARCHED, cts.N_WEIGHT]);\n    this.remove([cts.SEARCHED_2, cts.SECONDARY_TARGET, cts.SEARCHED_DONE]);\n    this.remove([cts.WEIGHT]);\n    this.predecessor = null;\n    this.dist = Infinity;\n  }\n\n  /**\n   * Return true if the node is the Target, Start or SecondaryTarget\n   */\n  isKeyValue() {\n    return (\n      this.is(cts.TARGET) || this.is(cts.START) || this.is(cts.SECONDARY_TARGET)\n    );\n  }\n\n  /**\n   * Adds CSS class to mark as shortest path and calls markShortestPath on predecessor\n   */\n  markShortestPath() {\n    if (!this.is(cts.TARGET) && !this.is(cts.START)) {\n      this.remove([cts.SEARCHED, cts.SEARCHED_2, cts.SEARCHED_DONE]);\n      this.add(cts.SHORTEST_PATH);\n    }\n    if (this.predecessor === null) return;\n    this.predecessor.markShortestPath();\n  }\n\n  /**\n   * Removes a list of CSS classes\n   * @param {string[]} classes\n   */\n  remove(classes) {\n    for (let i in classes) this.classes.remove(classes[i]);\n  }\n\n  /**\n   * Returns true if the Node contains input CSS class\n   * @param {string} name\n   */\n  is(name) {\n    return this.classes.contains(name);\n  }\n\n  /**\n   * Add CSS class to Node\n   * @param {string} name\n   */\n  add(name) {\n    this.classes.add(name);\n  }\n\n  /**\n   * Remove all CSS classes from the Node except Cell\n   */\n  clear() {\n    this.classes = [cts.CELL];\n  }\n}\n\n/**\n * Returns a reference to the node given the id\n * @param {Number} id\n * @param {Node[][]} nodeGrid\n */\nNode.getNode = (id, nodeGrid) => {\n  const width = nodeGrid[0].length;\n  const row = Math.floor((id - 1) / width);\n  const col = (id - 1) % width;\n  return nodeGrid[row][col];\n};\n","/**\n * AlgExecInfo class contains key information about the execution of a graph algorithm\n */\nexport default class AlgExecInfo {\n  constructor(animations, distance, algorithm, withAnimation, negativeCycle = false, kwargs) {\n    this.animations = animations;\n    this.distance = distance;\n    this.algorithm = algorithm;\n    this.negativeCycle = negativeCycle;\n    this.withAnimation = withAnimation;\n    this.kwargs = kwargs\n  }\n}\n","import { Queue } from \"./Queue\";\nimport { DisjointSet } from \"./DisjointSet\";\nimport { MinHeap } from \"../index\";\nimport Node from \"../Node\";\nimport * as cts from \"../constants\";\nimport AlgExecInfo from \"../AlgExecInfo\";\n\n/**\n * A graph ADT implementation\n */\nexport class Graph {\n  constructor(noOfVertices) {\n    this.noOfVertices = noOfVertices;\n    this.AdjList = new Map();\n  }\n\n  /**\n   * Adds a vertex object to the graph\n   *\n   * @param {*} v  Vertex Object\n   */\n  addVertex(v) {\n    // initialize the adjacent list with a\n    // null array\n    this.AdjList.set(v, []);\n  }\n\n  /**\n   * Adds an Edge to the graph\n   *\n   * @param {*} v start Vertex\n   * @param {*} w end Vertex\n   */\n  addEdge(v, w) {\n    // get the list for vertex v and put the\n    // vertex w denoting edge between v and w\n    this.AdjList.get(v).push(w);\n    // Since graph is undirected,\n    // add an edge from w to v also\n    // this.AdjList.get(w).push(v);\n  }\n\n  /**\n   * Print the current graph instance\n   */\n  printGraph() {\n    // get all the vertices\n    let get_keys = this.AdjList.keys();\n\n    // iterate over the vertices\n    for (let i of get_keys) {\n      // great the corresponding adjacency list\n      // for the vertex\n      let get_values = this.AdjList.get(i);\n      let conc = \"\";\n\n      // iterate over the adjacency list\n      // concatenate the values into a string\n      for (let j of get_values) conc += j + \" \";\n\n      // print the vertex and its adjacency list\n      console.log(i + \" -> \" + conc);\n    }\n  }\n\n  /**\n   * Perform Breadth First Search on the graph\n   *\n   * @param {*} startingNode Reference to the starting node\n   * @param {*} withAnimation Boolean indicating if animations are needed\n   */\n  bfs(startingNode, withAnimation) {\n    // Array to store the animations\n    const animations = [];\n\n    // Create a visited array\n    let visited = [];\n    for (let i = 0; i < this.noOfVertices; i++) visited[i] = false;\n\n    // Create an object for queue\n    let q = new Queue();\n\n    // add the starting node to the queue\n    visited[startingNode] = true;\n    q.enqueue(startingNode);\n\n    let dist = 0;\n    let minDistance = -1;\n\n    // loop until queue is element\n    while (!q.isEmpty()) {\n      const size = q.size();\n\n      for (let i = 0; i < size; i++) {\n        // get the element from the queue\n        let getQueueElement = q.dequeue();\n\n        // if Target update minDistance\n        if (getQueueElement.is(cts.TARGET)) minDistance = dist;\n\n        // passing the current vertex to callback function\n        // get the adjacent list for current vertex\n        let get_List = this.AdjList.get(getQueueElement);\n\n        // loop through the list and add the element to the\n        // queue if it is not processed yet\n        for (let n in get_List) {\n          let neigh = get_List[n];\n\n          if (!visited[neigh]) {\n            neigh.predecessor = getQueueElement;\n            neigh.dist = 1 + getQueueElement.dist;\n            if (!withAnimation) neigh.markSearched2Done();\n            if (neigh.is(cts.TARGET) && !withAnimation)\n              neigh.markShortestPath();\n\n            animations.push(neigh);\n            visited[neigh] = true;\n            q.enqueue(neigh);\n          }\n        }\n      }\n      dist++;\n    }\n\n    return new AlgExecInfo(animations, minDistance, cts.BFS, withAnimation);\n  }\n\n  /**\n   * Perform a Depth First Search on the graph\n   *\n   * @param {*} startingNode Reference to the starting node\n   * @param {*} withAnimation Boolean indicating if animations are desired\n   */\n  dfs(startingNode, withAnimation) {\n    if (!startingNode) return [];\n    const animations = [];\n\n    let visited = {};\n\n    const distance = this.DFSUtil(\n      startingNode,\n      visited,\n      animations,\n      withAnimation\n    );\n\n    return new AlgExecInfo(animations, distance, cts.DFS, withAnimation);\n  }\n\n  /**\n   *\n   * Depth First search recursive utility function: process and explore\n   * all the adjacent vertices of the input vertex\n   *\n   * @param {*} vert Reference to the starting node\n   * @param {*} visited Boolean of arrays indicating if a vertex has been visited\n   * @param {*} animations Array that holds the algorithm's animations\n   * @param {*} withAnimation Boolean indicating if animation is desired\n   */\n  DFSUtil(vert, visited, animations, withAnimation) {\n    visited[vert] = true;\n    let output = -1;\n    if (vert.is(cts.TARGET)) output = vert.dist;\n\n    let neighbors = this.AdjList.get(vert);\n\n    for (let neighbor of neighbors) {\n      neighbor.dist = vert.dist + 1;\n      if (!(neighbor in visited)) {\n        neighbor.predecessor = vert;\n        if (!withAnimation) neighbor.markSearched2Done();\n\n        if (neighbor.is(cts.TARGET) && !withAnimation) {\n          neighbor.markShortestPath();\n        }\n        animations.push(neighbor);\n        output = Math.max(\n          this.DFSUtil(neighbor, visited, animations, withAnimation),\n          output\n        );\n      }\n    }\n\n    return output;\n  }\n\n  /**\n   *\n   * Perform Dijkstra's Algorithm on the graph.\n   *\n   * @param {*} startNode Reference to the starting node\n   * @param {*} animations Array that will store the algorithm's animations\n   * @param {*} hasSecond Boolean indicating if there is targets in the graph\n   * @param {*} withAnimation Boolean indicating if animation is desired\n   */\n  dijkstra(startNode, withAnimation) {\n    if (!startNode) return [];\n    // Animations array\n    const animations = [];\n    // Visited set keeps track of the visited nodes, keep for when negative edges exists in the graph\n    const visited = {};\n\n    // Prioritize based on the node's distance\n    const heap = new MinHeap((item) => item.dist);\n\n    heap.push(startNode);\n\n    // Min Distance from source to target\n    let minDistance = -1;\n\n    while (!heap.isEmpty()) {\n      // Get the node with lowest distance\n      const currentNode = heap.pop();\n\n      // If we have found the target return the animations\n      if (currentNode.is(cts.TARGET)) {\n        if (!withAnimation) currentNode.markShortestPath();\n        minDistance = currentNode.dist;\n        break;\n      }\n\n      // Get neighbors\n      let neighbors = this.AdjList.get(currentNode);\n\n      // For each of neighbors\n      for (let adjacentNode of neighbors) {\n        // Only explore unvisited nodes\n        if (adjacentNode in visited) continue;\n        visited[adjacentNode] = true;\n        // Calculate distance via the neighbor\n        let tentativeDistance = adjacentNode.getWeight() + currentNode.dist;\n\n        if (tentativeDistance < adjacentNode.dist) {\n          // Path via neighbor is better, so record it.\n\n          // Handle animations\n          if (!withAnimation) adjacentNode.markSearched2Done();\n          animations.push(adjacentNode);\n\n          heap.push(adjacentNode);\n\n          // Update the parent\n          adjacentNode.predecessor = currentNode;\n\n          // Update the distance\n          adjacentNode.dist = tentativeDistance;\n        }\n      }\n    }\n\n    return new AlgExecInfo(\n      animations,\n      minDistance,\n      cts.DIJKSTRA,\n      withAnimation\n    );\n  }\n\n  /**\n   * Perform A* Algorithm to the graph\n   *\n   * @param {*} startNode Reference to the starting node\n   * @param {*} targetNode Reference to the target node\n   * @param {*} withAnimation Boolean indicating if animations are desired\n   */\n  aStar(startNode, targetNode, withAnimation) {\n    if (startNode === null) return [];\n    if (targetNode === null) return [];\n\n    // Visited set keeps track of the visited nodes, keep for when negative edges exists in the graph\n    const visited = {};\n\n    // Array to store nodes to animate\n    const animations = [];\n\n    // Prioritize based on the f parameter\n    const heap = new MinHeap((item) => item.f);\n\n    // g is zero for the start and Infinity for the rest of nodes\n    startNode.f = this.manhattanDistance(startNode, targetNode);\n\n    heap.push(startNode);\n\n    let minDistance = -1;\n\n    while (!heap.isEmpty()) {\n      // Get node in the priority queue having the lowest f value\n      const currentNode = heap.pop();\n\n      // The current distance of the currentNode\n      let currentdist = currentNode.dist;\n\n      // Get neighbors\n      let adj = this.AdjList.get(currentNode);\n\n      // Handle animations\n      if (!withAnimation) currentNode.markSearched2Done();\n      animations.push(currentNode);\n\n      if (currentNode.is(cts.TARGET)) {\n        if (!withAnimation) currentNode.markShortestPath();\n        minDistance = currentNode.dist;\n        break;\n      }\n\n      //for each of its adjacent nodes...\n      for (let adjacentNode of adj) {\n        if (adjacentNode in visited) continue;\n        visited[adjacentNode] = true;\n        // distance(current,neighbor) is the weight of the edge from current to neighbor\n        // tentativeGScore  is the distance from start to the neighbor through current\n        let tentativeGScore = currentdist + adjacentNode.getWeight();\n\n        if (tentativeGScore < adjacentNode.dist) {\n          // This path to neighbor is better than any previous one. Record it!\n\n          //reference parent\n          adjacentNode.predecessor = currentNode;\n\n          adjacentNode.dist = tentativeGScore;\n\n          // Set f value\n          const g = adjacentNode.dist;\n\n          const h = this.manhattanDistance(adjacentNode, targetNode);\n\n          adjacentNode.f = g + h;\n\n          heap.push(adjacentNode);\n        }\n      }\n    }\n\n    // We did not find the target\n    return new AlgExecInfo(animations, minDistance, cts.ASTAR, withAnimation);\n  }\n\n  /**\n   * Returns the ManhattanDistance between two graph nodes\n   *\n   * @param {*} node first node\n   * @param {*} targetNode second node\n   */\n  manhattanDistance(node, targetNode) {\n    return (\n      Math.abs(node.col - targetNode.col) + Math.abs(node.row - targetNode.row)\n    );\n  }\n  /**\n   * Perform Greedy Best First search on the graph\n   *\n   * @param {*} startNode Reference to the starting node\n   * @param {*} targetNode Reference to the target node\n   * @param {*} withAnimation Boolean indicating if animations are desired\n   */\n  bestFirstSearch(startNode, targetNode, withAnimation) {\n    if (startNode === null) return [];\n    if (targetNode === null) return [];\n\n    // Map to store visited nodes\n    const visited = {};\n\n    // Array to store the animations\n    const animations = [];\n\n    // Create Empty Priority Queue\n    const heap = new MinHeap((item) => item.f);\n\n    startNode.g = 0;\n    this.greedyHeuristic(startNode, targetNode);\n\n    // Insert start in priority queue\n    heap.push(startNode);\n\n    let distance = -1;\n\n    while (!heap.isEmpty()) {\n      // Remove vertex with smallest cost\n      const currentNode = heap.pop();\n\n      // Check if currentNode is target and handle animations\n      if (currentNode.is(cts.TARGET)) {\n        animations.push(currentNode);\n        if (!withAnimation) currentNode.markShortestPath();\n        distance = currentNode.dist;\n        break;\n      }\n\n      let currentdist = currentNode.dist;\n\n      // Get neighbors of currentNode\n      let adj = this.AdjList.get(currentNode);\n\n      // Handle animations\n      if (!withAnimation) currentNode.markSearched2Done();\n      animations.push(currentNode);\n\n      //for each adjacent node\n      for (let a in adj) {\n        const adjacentNode = adj[a];\n\n        //choose nearest node with lowest *total* cost\n        let d = adjacentNode.getWeight() + currentdist;\n\n        // if the vertex is unvisited and distance is improved\n        if (!(adjacentNode.id in visited) && d < adjacentNode.dist) {\n          this.greedyHeuristic(adjacentNode, targetNode);\n\n          if (!heap.contains(adjacentNode)) heap.push(adjacentNode);\n\n          // Update the parent and distance\n          adjacentNode.predecessor = currentNode;\n          adjacentNode.dist = d;\n\n          // Mark as visited\n          visited[adjacentNode.id] = true;\n        }\n      }\n    }\n\n    return new AlgExecInfo(animations, distance, cts.GREEDY_BFS, withAnimation);\n  }\n\n  /**\n   * Update Greedy Heurisitc on two input nodes\n   *\n   * @param {*} node\n   * @param {*} targetNode\n   */\n  greedyHeuristic(node, targetNode) {\n    // Calculate the Euclidean distance between the node and target\n    const h = Math.sqrt(\n      Math.pow(node.col - targetNode.col, 2) +\n        Math.pow(node.row - targetNode.row, 2)\n    );\n    node.h = Math.floor(h);\n    node.f = node.h;\n  }\n\n  /**\n   * Update Euclidean distance between two nodes\n   *\n   * @param {*} node\n   * @param {*} targetNode\n   */\n  euclideanDistance(node, targetNode) {\n    const h = Math.sqrt(\n      Math.pow(node.col - targetNode.col, 2) +\n        Math.pow(node.row - targetNode.row, 2)\n    );\n    node.h = Math.floor(h);\n    node.f = node.getWeight() + node.h;\n  }\n\n  /**\n   * Perform D* Algorithm on the graph\n   *\n   * @param {*} startNode Reference to start node\n   * @param {*} targetNode Reference to target node\n   * @param {*} withAnimation Boolean indicating if animations are desired\n   */\n  dStar(startNode, targetNode, withAnimation) {\n    if (targetNode === null) return [];\n\n    const queue = new Queue();\n    const animations = [];\n\n    targetNode.dist = 0;\n    queue.enqueue(targetNode);\n\n    let minDistance = -1;\n\n    while (!queue.isEmpty()) {\n      const currentNode = queue.dequeue();\n      const adj = this.AdjList.get(currentNode); // get neighbors\n      for (let neighbor of adj) {\n        const dist = 1 + currentNode.dist;\n        if (dist < neighbor.dist || neighbor.is(cts.START)) {\n          if (!withAnimation) neighbor.markSearched2Done();\n          animations.push(neighbor);\n          neighbor.dist = dist;\n          neighbor.predecessor = currentNode;\n          if (neighbor === startNode) {\n            if (!withAnimation) {\n              neighbor.markShortestPath();\n            }\n            break;\n          }\n          queue.enqueue(neighbor);\n        }\n      }\n    }\n\n    return new AlgExecInfo(animations, minDistance, cts.DSTAR, withAnimation);\n  }\n\n  /**\n   * Perform Prim's Algorithm on the graph\n   *\n   * @param {*} startNode Reference to start node\n   * @param {*} targetNode Reference to target node\n   * @param {*} withAnimation Boolean indicating if animations are desired\n   */\n  Prims(startNode, targetNode, withAnimation) {\n    if (startNode === null) return [];\n    if (targetNode === null) return [];\n\n    const heap = new MinHeap((node) => node.dist);\n    const mst = {};\n    const animations = [];\n    startNode.dist = 0;\n    heap.push(startNode);\n\n    while (!heap.isEmpty()) {\n      const currentNode = heap.pop();\n\n      const adjacentNodes = this.AdjList.get(currentNode);\n\n      animations.push(currentNode);\n\n      for (let adj of adjacentNodes) {\n        if (adj.dist > adj.getWeight()) {\n          !withAnimation && adj.markSearched2Done();\n          heap.push(adj);\n          adj.dist = adj.getWeight();\n        }\n      }\n\n      mst[currentNode.toString()] = currentNode;\n    }\n\n    if (!withAnimation) targetNode.markShortestPath();\n\n    return new AlgExecInfo(animations, cts.UNK, cts.PRIMS, withAnimation);\n  }\n\n  /**\n   * Perform kruskal's algorithm\n   */\n  kruskal() {\n    // Heap used to order the edges\n    const heap = new MinHeap((el) => el.w);\n\n    // Disjoint set to keep track of cycles\n    const ds = new DisjointSet(5000);\n    const mst = [];\n    const edges = {};\n    const animations = [];\n\n    // Go thru all edges\n    this.AdjList.forEach((arr, key) => {\n      arr.forEach((adj) => {\n        const edgeId = [key.id, adj.id];\n        edgeId.sort((a, b) => a - b);\n\n        // Add the edge to the heap\n        if (!edges.hasOwnProperty(edgeId.toString())) {\n          edges[edgeId] = true;\n          heap.push({\n            nodes: [key, adj],\n            w: key.getWeight() + adj.getWeight() - 1,\n            i: key.id,\n            j: adj.id,\n          });\n        }\n      });\n    });\n\n    // Go thru the heap contents\n    while (!heap.isEmpty()) {\n      const currentEdge = heap.pop();\n      const hasCycle = ds.hasCycle(currentEdge.i, currentEdge.j);\n\n      // If the edge does not cause a cycle add it to the MST\n      if (!hasCycle) {\n        animations.push(currentEdge.nodes[0]);\n        animations.push(currentEdge.nodes[1]);\n        mst.push(currentEdge);\n      }\n    }\n\n    return new AlgExecInfo(animations, cts.UNK, cts.KRUSKAL, true);\n  }\n\n  /**\n   * Perform Bellman Ford's Algorithm on the graph\n   * @param {*} startNode Reference to start node\n   * @param {*} nodeGrid Reference to node Grid\n   * @param {*} withAnimation Boolean indicating if animations are desired\n   */\n  bellmanFord(startNode, targetNode, nodeGrid, withAnimation) {\n    if (startNode === null) return [];\n    // Initialize startVertex by setting dist = 0\n    startNode.dist = 0;\n\n    // HashMap to store the nodes By their ID\n    const nodes = {};\n\n    // Calculate number of nodes\n    const n = nodeGrid.length * nodeGrid[0].length;\n\n    // Create a HashMap Of Id -> Node Obj\n    for (let id = 1; id <= n; id++) {\n      // get Node Given an Id\n      const node = Node.getNode(id, nodeGrid);\n      nodes[id] = node;\n    }\n\n    // Animate all nodes\n    let animations = [...Object.values(nodes)];\n    animations = animations.filter((node) => !node.is(cts.WALL));\n\n    // Relax the edges\n    for (let i = 1; i < this.noOfVertices; i++) {\n      // Go thru all edges and relax them\n      this.AdjList.forEach((arr, key) => {\n        arr.forEach((adj) => {\n          if (key.dist > adj.dist + adj.getWeight()) {\n            key.dist = adj.dist + adj.getWeight();\n            key.predecessor = adj;\n          }\n        });\n      });\n    }\n\n    let containsNegativeCycle = false;\n\n    // Check for negative-weight cycles\n    this.AdjList.forEach((arr, key) => {\n      arr.forEach((adj) => {\n        if (adj.dist + adj.getWeight() < key.dist) {\n          containsNegativeCycle = true;\n        }\n      });\n    });\n\n    if (containsNegativeCycle) {\n      // Remove predecessor to avoid infinite path cycle\n      this.AdjList.forEach((arr, key) => {\n        key.predecessor = null;\n      });\n    }\n\n    return new AlgExecInfo(\n      animations,\n      targetNode.dist,\n      cts.BELLMAN_FORD,\n      withAnimation,\n      containsNegativeCycle\n    );\n  }\n\n  /**\n   * Perform a Bidirectional BFS starting at startNode and targetNode\n   * @param {Node} startNode\n   * @param {Node} targetNode\n   */\n  bidirectionalBFS(startNode, targetNode) {\n    const animations = [];\n    const visited = {};\n    const queue = new Queue();\n    queue.enqueue(startNode);\n    queue.enqueue(targetNode);\n    visited[startNode] = true;\n    visited[targetNode] = true;\n\n    while (!queue.isEmpty()) {\n      const size = queue.size();\n      for (let i = 0; i < size; i++) {\n        const curr = queue.dequeue();\n        const neighbors = this.AdjList.get(curr);\n\n        for (let neigh of neighbors) {\n          if (neigh in visited) {\n            continue;\n          }\n          animations.push(neigh);\n          neigh.predecessor = curr;\n          visited[neigh] = true;\n          queue.enqueue(neigh);\n        }\n      }\n    }\n\n    return new AlgExecInfo(\n      animations,\n      targetNode.dist,\n      cts.BIDIRECTIONAL_BFS,\n      true\n    );\n  }\n}\n","/* \n  In a complete Binary Tree, For any ith node:\n  Arr[(i -1) / 2] returns its parent node.\n  Arr[(2 * i) + 1] returns its left child node.\n  Arr[(2 * i) + 2] returns its right child node.\n*/\n\n/**\n * Min Heap implementation\n */\nexport class MinHeap {\n  /**\n   * function that return that value of two items\n   */\n  selector = null;\n\n  constructor(selector) {\n    this.items = [];\n    this.selector = selector;\n  }\n  /**\n   * Returns the Top most element from the Heap without removal\n   * @return {Object} obj\n   */\n  peek() {\n    return this.items[0];\n  }\n\n  /**\n   * Insert an item into the Heap\n   * @param {Object} item\n   */\n  push(item) {\n    let i = this.items.length;\n    this.items.push(item);\n\n    let parentIndex = this.getParentIndex(i);\n\n    let parentVal = this.selector(this.items[parentIndex]);\n    const pushedVal = this.selector(this.items[i]);\n\n    while (parentVal > pushedVal) {\n      this.swap(i, parentIndex);\n\n      i = parentIndex;\n      parentIndex = this.getParentIndex(i);\n\n      parentVal = this.selector(this.items[parentIndex]);\n    }\n  }\n\n  /**\n   * Returns parent index of an input index.\n   * For index 0, the parent is 0.\n   * @param {number} index\n   * @returns {number} index - parent index\n   */\n  getParentIndex(index) {\n    return Math.max(Math.floor((index - 1) / 2), 0);\n  }\n\n  /**\n   * Returns the right child index\n   * @param {number} index\n   * @returns {number} index - right child index\n   */\n  getRightIndex(index) {\n    return 2 * index + 2;\n  }\n\n  /**\n   * Returns the left child index\n   * @param {number} index\n   * @returns {number} index - left child index\n   */\n  getLeftIndex(index) {\n    return 2 * index + 1;\n  }\n\n  /**\n   * Swap Two elements from the items list\n   * @param {number} i index i\n   * @param {number} j index j\n   */\n  swap(i, j) {\n    let t = this.items[i];\n    this.items[i] = this.items[j];\n    this.items[j] = t;\n  }\n\n  /**\n   * Remove an Element from the Heap\n   * @returns {Object} obj - heap Element\n   */\n  pop() {\n    if (this.items.length <= 1) return this.items.pop(); //If it is the last element pop it\n    const ret = this.items[0]; // What we will return\n    let temp = this.items.pop(); // Remove first item from items list\n    this.items[0] = temp; // Place last element in array at front\n\n    let i = 0; // We adjust heap from top to down\n\n    while (true) {\n      let rightChildIndex = this.getRightIndex(i);\n      let leftChildIndex = this.getLeftIndex(i);\n      // Hold the index of the lowest child\n      let lowest = rightChildIndex;\n\n      let leftIndexOB = leftChildIndex >= this.items.length;\n      let rightIndexOB = rightChildIndex >= this.items.length;\n\n      // If both children are non-existent, we have finished setting up the heap\n      if (leftIndexOB && rightIndexOB) break;\n\n      // If left child is OB set lowest equal to the rightChildIndex\n      if (leftIndexOB) lowest = rightChildIndex;\n      // If right child is OB set lowest equal to the leftChildIndex\n      if (rightIndexOB) lowest = leftChildIndex;\n\n      let bothChildrenInBounds = !leftIndexOB && !rightIndexOB;\n\n      if (bothChildrenInBounds) {\n        lowest =\n          this.selector(this.items[rightChildIndex]) <\n          this.selector(this.items[leftChildIndex])\n            ? rightChildIndex\n            : leftChildIndex;\n      } // Find the smallest child\n\n      // If the parent is greater than the smallest child: swap\n      if (this.selector(this.items[i]) > this.selector(this.items[lowest])) {\n        this.swap(i, lowest);\n        i = lowest;\n      } else {\n        break;\n      } // We have finished setting up the heap\n    }\n\n    // Return topmost element\n    return ret;\n  }\n\n  /**\n   * Return true if the heap contains the input item\n   * @param {Object} item\n   */\n  contains(item) {\n    return this.items.includes(item);\n  }\n\n  /**\n   * Returns true if the heap is empty\n   * @returns {boolean} boolean\n   */\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  /**\n   * Remove an Item from the heap\n   * @param {Object} item\n   */\n  delete(item) {\n    let i = this.items.indexOf(item);\n    // heapify\n    this.items[i] = this.items.pop();\n    while (true) {\n      let lowest =\n        this.selector(this.items[this.getRightIndex(i)]) <\n        this.selector(this.items[(i + 1) * 2 - 1])\n          ? (i + 1) * 2\n          : (i + 1) * 2 - 1;\n      if (this.selector(this.items[i]) > this.selector(this.items[lowest])) {\n        let t = this.items[i];\n        this.items[i] = this.items[lowest];\n        this.items[lowest] = t;\n        i = lowest;\n      } else break;\n    }\n  }\n\n  /**\n   * Print the contents of the Heap\n   */\n  print() {\n    for (let i = 0; i < this.items.length; i++) {\n      console.log(this.items[i]);\n    }\n  }\n\n  /**\n   * Heapify\n   * @param {Object[]} arr\n   */\n  heapify(arr) {\n    for (let i = 0; i < arr.length; i++) {\n      this.push(arr[i]);\n    }\n  }\n}\n","import AlgExecInfo from \"../AlgExecInfo\";\nimport * as cts from \"../constants\";\n/**\n * Run Floyd Warshall's All Pairs shortest paths algorithm on a nodeGrid\n * @param {Node[][]} nodeGrid\n */\nexport const floydWarshall = (nodeGrid) => {\n  // calculate number of vertices\n  const n = nodeGrid.length * nodeGrid[0].length;\n\n  // distance matrix that holds distance from i -> j at mtrx[i][j]\n  const mtrx = [];\n  const animations = [];\n  let distance = 1;\n\n  // 2D array that stores the path from any pair of vertices\n  const path = new Array(n);\n\n  // HashMap to store the nodes By their ID id -> Node\n  const nodes = {};\n\n  // Variables to hold the startNode and targetNode id,\n  // used to get the distance between the two at the conclusion of the algo.\n  let startId = 0;\n  let targetId = 0;\n\n  // For each vertex ID\n  for (let i = 1; i <= n; i++) {\n    // Get node given ID : i\n    const node = getNode(i, nodeGrid);\n\n    // Save it to Hashmap for later use\n    nodes[i] = node;\n\n    path[i] = [];\n\n    path[i][i] = i;\n\n    // Get list of vertex neighbors\n    const neighbors = node.getNeighbors(nodeGrid);\n\n    // For Each neighbor\n    for (let neighbor of neighbors) {\n      path[i][neighbor.id] = neighbor.id;\n    }\n\n    // Record the id of start and target node\n    if (node.is(cts.START)) startId = node.id;\n    if (node.is(cts.TARGET)) targetId = node.id;\n\n    // Handle animation\n    if (!node.is(cts.WALL)) animations.push(node);\n  }\n\n  // Initialize the distance matrix\n  for (let row = 1; row <= n; row++) {\n    mtrx[row] = [];\n    for (let col = 1; col <= n; col++) {\n      // The node at row\n      const start = nodes[row];\n\n      // The node at col\n      const end = nodes[col];\n\n      if (!path[row][col]) path[row][col] = 0;\n\n      // Distance from start to end\n      mtrx[row][col] = start.getDistanceTo(end);\n    }\n  }\n\n  // Update the mtrx\n  for (let k = 1; k <= n; k++) {\n    for (let i = 1; i <= n; i++) {\n      for (let j = 1; j <= n; j++) {\n        // Keep the code inside here lean so that it remains fast\n\n        // If it is faster via node with id k\n        if (mtrx[i][k] + mtrx[k][j] < mtrx[i][j]) {\n          mtrx[i][j] = mtrx[i][k] + mtrx[k][j];\n          path[i][j] = path[i][k];\n        }\n      }\n    }\n  }\n\n  let containsNegativeCycle = false;\n\n  // If distance of any verex from itself\n  // becomes negative, then there is a negative\n  // weight cycle.\n  for (let i = 1; i <= n; i++) {\n    if (mtrx[i][i] < 0) {\n      containsNegativeCycle = true;\n      break;\n    }\n  }\n\n  if (containsNegativeCycle) {\n    path.forEach((arr) => arr.fill(0));\n  }\n\n  // Update the distances on the start and target node so that the UI Updates\n  distance = mtrx[startId][targetId];\n\n  return new AlgExecInfo(\n    animations,\n    distance,\n    cts.FLOYD_WARSHALL,\n    true,\n    containsNegativeCycle,\n    { mtrx, path }\n  );\n};\n\n/**\n * Returns a reference to the node given the id\n * @param {*} id\n * @param {*} nodeGrid\n */\nfunction getNode(id, nodeGrid) {\n  const width = nodeGrid[0].length;\n  const row = Math.floor((id - 1) / width);\n  const col = (id - 1) % width;\n  return nodeGrid[row][col];\n}\n\n/**\n * Return array of path given ID: u, v, and path matrix\n * @param {*} u\n * @param {*} v\n * @param {*} path\n */\nexport const getPath = (u, v, path) => {\n  if (path[u][v] === 0) return [];\n  const result = [];\n  while (u !== v) {\n    u = path[u][v];\n    result.push(u);\n  }\n  return result;\n};\n","import { useState, useCallback } from \"react\";\nimport Node from \"../utility/Node\";\nimport * as cts from \"../utility/constants\";\n\nconst generateNodeGrid = (numRows, numCols) => {\n  const nodesGrid = [];\n  let id = 1;\n\n  for (let row = 0; row < numRows; row++) {\n    nodesGrid[row] = [];\n    for (let col = 0; col < numCols; col++) {\n      nodesGrid[row][col] = new Node(row, col, id);\n      id++;\n    }\n  }\n\n  return nodesGrid;\n};\n\nconst useNodeGrid = (rows, cols) => {\n  const [numRows, setNumRows] = useState(rows);\n  const [numCols, setNumCols] = useState(cols);\n\n  const nodeGrid = useCallback(generateNodeGrid(numRows, numCols), [\n    numRows,\n    numCols,\n  ]);\n\n  const resetGrid = () => {\n    for (let row in nodeGrid) {\n      for (let cell of nodeGrid[row]) {\n        cell.reset();\n      }\n    }\n  };\n\n  const clearGrid = () => {\n    for (let row in nodeGrid) {\n      for (let cell of nodeGrid[row]) {\n        cell.reset();\n        cell.remove([cts.START, cts.TARGET]);\n      }\n    }\n  };\n\n  const removeVisuals = () => {\n    for (let row in nodeGrid) {\n      for (let node of nodeGrid[row]) {\n        node.removeVisuals();\n      }\n    }\n  };\n\n  const paintInDistance = (dist) => {\n    if (dist === Infinity) return;\n    for (let row in nodeGrid) {\n      for (let node of nodeGrid[row]) {\n        if (node.dist <= dist) {\n          node.markSearched2Done();\n        } else {\n          node.removeClasses();\n        }\n      }\n    }\n  };\n\n  /**\n   *  Resets the distance and predecessors of each node in the nodeGrid.\n   */\n  const resetDistance = () => {\n    for (let row in nodeGrid) {\n      for (let node of nodeGrid[row]) {\n        node.dist = Infinity;\n        node.predecessor = null;\n        if (!node.isKeyValue()) {\n          node.removeClasses();\n        }\n      }\n    }\n  };\n\n  return {\n    nodeGrid,\n    resetGrid,\n    removeVisuals,\n    paintInDistance,\n    resetDistance,\n    clearGrid,\n    setNumRows: (numRows) => {\n      clearGrid();\n      setNumRows(numRows);\n    },\n    setNumCols: (numCols) => {\n      clearGrid();\n      setNumCols(numCols);\n    },\n    numRows,\n    numCols,\n  };\n};\n\nexport default useNodeGrid;\n","import React from \"react\";\nimport classes from \"./NavigationItem.module.css\";\n\nconst NavigationItem = ({ children, clicked, style = {} }) => (\n  <div className={classes.NavigationItem}>\n    <button onClick={clicked} className={classes.Btn} style={style}>\n      {children}\n    </button>\n  </div>\n);\nexport default NavigationItem;\n","import React from \"react\";\nimport \"./DropDown.css\";\n\nconst DropDown = ({ children, title }) => {\n  return (\n    <div className=\"dropdown\">\n      <button className=\"dropbtn\">\n        {title}\n      </button>\n      <div className=\"dropdown-content\">\n        {children}\n      </div>\n    </div>\n  );\n};\n\nexport default DropDown;\n","import React from \"react\";\nimport \"./Subnav.css\";\n\nconst Subnav = ({ children, title }) => {\n  return (\n    <div className=\"subnav\">\n      <button className=\"subnavbtn\">{title}</button>\n      <div className=\"subnav-content\">{children}</div>\n    </div>\n  );\n};\n\nexport default Subnav;\n","import React from \"react\";\n\nconst DropItem = ({children, clicked}) => {\nreturn <p onClick={clicked}>{children}</p>;\n};\n\nexport default DropItem;\n","import { useState, useEffect } from \"react\";\n\nlet globalState = {};\nlet listeners = [];\nlet actions = {};\n\nexport const useStore = (shouldListen = true) => {\n  const setState = useState(globalState)[1];\n\n  const dispatch = (actionId, payload) => {\n    const newPortfolio = actions[actionId](globalState, payload);\n    globalState = { ...globalState, ...newPortfolio };\n\n    for (const listener of listeners) {\n      listener(globalState);\n    }\n  };\n\n  useEffect(() => {\n    if (shouldListen) {\n      listeners.push(setState);\n    }\n\n    return () => {\n      if (shouldListen) {\n        listeners = listeners.filter((li) => li !== setState);\n      }\n    };\n  }, [setState, shouldListen]);\n\n  return [globalState, dispatch];\n};\n\nexport const initStore = (userActions, initialState) => {\n  if (initialState) {\n    globalState = { ...globalState, ...initialState };\n  }\n\n  actions = { ...actions, ...userActions };\n};\n","import React from \"react\";\nimport NavigationItem from \"./NavigationItem/NavigationItem\";\nimport * as cts from \"../../../utility\";\nimport DropDown from \"./Dropdown/DropDown\";\nimport Subnav from \"./Subnav/Subnav\";\nimport DropItem from \"./Dropdown/DropItem/DropItem\";\nimport { useStore } from \"../../../hooks-store/store\";\n\nconst NavigationItems = ({\n  reset,\n  executeAlgorithm,\n  algorithm,\n  mazeGen,\n  setSpeed,\n  openDialog,\n  clear,\n  setUserAction,\n  setNumRows,\n}) => {\n  const dispatch = useStore(false)[1];\n  return (\n    <>\n      <NavigationItem clicked={openDialog}>ABOUT</NavigationItem>\n      <Subnav title=\"Algorithms\">\n        <DropDown title={cts.DIJKSTRA}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.DIJKSTRA });\n              dispatch(\"SET_ALGO\", { algo: cts.DIJKSTRA });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem\n            clicked={() => dispatch(\"SET_INFO\", { info: cts.DIJKSTRA })}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.ASTAR}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.ASTAR });\n              dispatch(\"SET_ALGO\", { algo: cts.ASTAR });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem clicked={() => dispatch(\"SET_INFO\", { info: cts.ASTAR })}>\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.GREEDY_BFS}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.GREEDY_BFS });\n              dispatch(\"SET_ALGO\", { algo: cts.GREEDY_BFS });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem\n            clicked={() => dispatch(\"SET_INFO\", { info: cts.GREEDY_BFS })}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.BFS}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_ALGO\", { algo: cts.BFS });\n              dispatch(\"SET_INFO\", { info: cts.BFS });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem clicked={() => dispatch(\"SET_INFO\", { info: cts.BFS })}>\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.DFS}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.DFS });\n              dispatch(\"SET_ALGO\", { algo: cts.DFS });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.DFS });\n            }}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.PRIMS}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.PRIMS });\n              dispatch(\"SET_ALGO\", { algo: cts.PRIMS });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.PRIMS });\n            }}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.KRUSKAL}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.KRUSKAL });\n              dispatch(\"SET_ALGO\", { algo: cts.KRUSKAL });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.KRUSKAL });\n            }}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.FLOYD_WARSHALL}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.FLOYD_WARSHALL });\n              dispatch(\"SET_ALGO\", { algo: cts.FLOYD_WARSHALL });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.KRUSKAL });\n            }}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.DSTAR}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_ALGO\", { algo: cts.DSTAR });\n              dispatch(\"SET_INFO\", { info: cts.DSTAR });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem clicked={() => dispatch(\"SET_INFO\", { info: cts.DSTAR })}>\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.BELLMAN_FORD}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_ALGO\", { algo: cts.BELLMAN_FORD });\n              dispatch(\"SET_INFO\", { info: cts.BELLMAN_FORD });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem\n            clicked={() => dispatch(\"SET_INFO\", { info: cts.BELLMAN_FORD })}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.BIDIRECTIONAL_BFS}>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_ALGO\", { algo: cts.BIDIRECTIONAL_BFS });\n              dispatch(\"SET_INFO\", { info: cts.BIDIRECTIONAL_BFS });\n            }}\n          >\n            Select\n          </DropItem>\n          <DropItem\n            clicked={() =>\n              dispatch(\"SET_INFO\", { info: cts.BIDIRECTIONAL_BFS })\n            }\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n      </Subnav>\n      <Subnav title=\"Maze Generators\">\n        <DropDown title={cts.RAND_MAZE}>\n          <DropItem clicked={() => mazeGen(cts.RAND_MAZE, cts.WALL)}>\n            Generate Walls\n          </DropItem>\n          <DropItem clicked={() => mazeGen(cts.RAND_MAZE, cts.WEIGHT)}>\n            Generate Weights\n          </DropItem>\n          <DropItem\n            clicked={() => dispatch(\"SET_INFO\", { info: cts.RAND_MAZE })}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.PRIMS_ALGO}>\n          <DropItem clicked={() => mazeGen(cts.PRIMS_ALGO, cts.WALL)}>\n            Generate Walls (Vanilla)\n          </DropItem>\n          <DropItem clicked={() => mazeGen(cts.PRIMS_ALGO, cts.WEIGHT)}>\n            Generate Weights (Vanilla)\n          </DropItem>\n          <DropItem clicked={() => mazeGen(cts.PRIMS_ALGO_531, cts.WALL)}>\n            Generate Walls (5,0,3)\n          </DropItem>\n          <DropItem clicked={() => mazeGen(cts.PRIMS_ALGO_531, cts.WEIGHT)}>\n            Generate Weights (5,0,3)\n          </DropItem>\n          <DropItem\n            clicked={() => dispatch(\"SET_INFO\", { info: cts.PRIMS_ALGO })}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.RECURSIVE_DIVISON}>\n          <DropItem clicked={() => mazeGen(cts.RECURSIVE_DIVISON, cts.WALL)}>\n            Generate Walls\n          </DropItem>\n          <DropItem clicked={() => mazeGen(cts.RECURSIVE_DIVISON, cts.WEIGHT)}>\n            Generate Weights\n          </DropItem>\n          <DropItem\n            clicked={() => {\n              dispatch(\"SET_INFO\", { info: cts.RECURSIVE_DIVISON });\n            }}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n        <DropDown title={cts.DRAW_COUNTOUR}>\n          <DropItem clicked={() => mazeGen(cts.DRAW_COUNTOUR, cts.WALL)}>\n            Generate Walls\n          </DropItem>\n          <DropItem clicked={() => mazeGen(cts.DRAW_COUNTOUR, cts.WEIGHT)}>\n            Generate Weights\n          </DropItem>\n          <DropItem\n            clicked={() => dispatch(\"SET_INFO\", { info: cts.DRAW_COUNTOUR })}\n          >\n            Learn More\n          </DropItem>\n        </DropDown>\n      </Subnav>\n      <Subnav title=\"Options\">\n        <DropDown title=\"Draw\">\n          <DropItem clicked={() => setUserAction(cts.DELETING)}>\n            Delete Wall\n          </DropItem>\n          <DropItem clicked={() => setUserAction(cts.PLACING_WALLS)}>\n            Draw Wall\n          </DropItem>\n        </DropDown>\n        <DropDown title=\"Add Weight\">\n          <DropItem clicked={() => setUserAction(cts.ADDING_WEIGHT)}>\n            Add Weight\n          </DropItem>\n          <DropItem clicked={() => setUserAction(cts.ADDING_N_WEIGHT)}>\n            Add Negative Weight\n          </DropItem>\n          <DropItem clicked={() => setUserAction(cts.PLACING_WALLS)}>\n            Draw Wall\n          </DropItem>\n        </DropDown>\n        <DropDown title=\"Set Grid Size\">\n          <DropItem\n            clicked={() => {\n              setNumRows(10);\n            }}\n          >\n            Small\n          </DropItem>\n          <DropItem\n            clicked={() => {\n              setNumRows(20);\n            }}\n          >\n            Medium\n          </DropItem>\n          <DropItem clicked={() => setNumRows(30)}>\n            Large (Beware of Lag)\n          </DropItem>\n        </DropDown>\n        <DropDown title=\"Set Animation Speed\">\n          <DropItem\n            clicked={() => {\n              setSpeed(100);\n            }}\n          >\n            Slow\n          </DropItem>\n          <DropItem\n            clicked={() => {\n              setSpeed(50);\n            }}\n          >\n            Medium\n          </DropItem>\n          <DropItem clicked={() => setSpeed(10)}>Fast</DropItem>\n        </DropDown>\n      </Subnav>\n\n      {/* <NavigationItem clicked={() => settingSecondTarget(true)}>Add Second Target</NavigationItem> */}\n      <NavigationItem clicked={reset}>Reset</NavigationItem>\n      <NavigationItem clicked={clear}>Clear Visualization</NavigationItem>\n      <NavigationItem clicked={executeAlgorithm} style={{ color: \"red\" }}>\n        Visualize {algorithm}!\n      </NavigationItem>\n    </>\n  );\n};\nexport default NavigationItems;\n","import React from \"react\";\nimport classes from \"./Toolbar.module.css\";\nimport NavigationItems from \"../NavigationItems/NavigationItems\";\n\nconst toolbar = (props) => {\n  return (\n    <header className={classes.Toolbar}>\n        <NavigationItems {...props} />\n    </header>\n  );\n};\nexport default toolbar;\n","import React, { useState } from \"react\";\nimport Cell from \"./Cell/Cell\";\nimport * as util from \"../utility/index\";\nimport \"./Board.css\";\nimport useNodeGrid from \"../hooks/useNodeGrid\";\nimport Navbar from \"./Navigation/Toolbar/Toolbar\";\nimport { useStore } from \"../hooks-store/store\";\nimport { Paper, makeStyles } from \"@material-ui/core\";\nimport { getPath } from \"../utility/Algorithms/floydWarshall\";\nimport Node from \"../utility/Node\";\nimport { BELLMAN_FORD } from \"../utility/index\";\n\nconst ROWS_INIT = 10;\nconst COLS_INIT = 40;\nlet pathMtrx = null;\n\nconst useStyles = makeStyles({\n  paper: {\n    padding: \"5px\",\n    margin: \"auto\",\n    width: \"1200px\",\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n  },\n});\n\n/**\n * Board Component\n * @param {*} param0\n */\nconst Board = ({ openDialog }) => {\n  const { algorithm } = useStore()[0];\n  const classes = useStyles();\n\n  console.log(\"Board\");\n\n  const {\n    nodeGrid,\n    resetGrid,\n    removeVisuals,\n    resetDistance,\n    setNumRows,\n    setNumCols,\n    numRows,\n    numCols,\n  } = useNodeGrid(ROWS_INIT, COLS_INIT);\n  const [isMouseDown, setIsMouseDown] = useState(false);\n  const [animating, setIsAnimating] = useState(true);\n  const [isMovingTarget, setIsMovingTarget] = useState(false);\n  const [isMovingStart, setIsMovingStart] = useState(false);\n  const [settingSecondTarget, setSettingSecondTarget] = useState(false);\n  const [prevAlgorithm, setPrevAlgorithm] = useState();\n  const [userAction, setUserAction] = useState(util.PLACING_WALLS);\n  const [animationSpeed, setAnimationSpeed] = useState(10);\n  const [distance, setDistance] = useState(util.UNK);\n  const [matrix, setMatrix] = useState(null);\n\n  const handleKeyNodeMove = (node, type) => {\n    if (type === util.TARGET) node.setAsTarget();\n    if (type === util.START) node.add(util.START);\n    if (prevAlgorithm !== util.FLOYD_WARSHALL) resetDistance();\n\n    const { startNode, targetNode } = util.getKeyNodes(nodeGrid);\n\n    switch (prevAlgorithm) {\n      case util.DIJKSTRA:\n        Dijkstra(false);\n        break;\n      case util.ASTAR:\n        AStar(false);\n        break;\n      case util.GREEDY_BFS:\n        bestFirstSearch(false);\n        break;\n      case util.BFS:\n        BFS(false);\n        break;\n      case util.DFS:\n        DFS(false);\n        break;\n      case util.DSTAR:\n        DStar(false);\n        break;\n      case util.PRIMS:\n        Prims(false);\n        break;\n      case util.FLOYD_WARSHALL:\n        setDistance(matrix[startNode.id][targetNode.id]);\n        drawPath(startNode.id, targetNode.id);\n        break;\n      case util.BELLMAN_FORD:\n        bellmanFord(false);\n        targetNode.markShortestPath();\n        break;\n      default:\n    }\n\n    if (\n      prevAlgorithm !== util.FLOYD_WARSHALL &&\n      prevAlgorithm !== util.BELLMAN_FORD\n    )\n      setDistance(targetNode.dist === Infinity ? util.UNK : targetNode.dist);\n  };\n\n  const onMouseEnterHandler = (node) => {\n    if (!animating) return;\n    if (settingSecondTarget) {\n      return node.setAsSecondTarget();\n    }\n    if (isMouseDown && isMovingStart && !node.is(util.TARGET)) {\n      return handleKeyNodeMove(node, util.START);\n    }\n    if (isMouseDown && isMovingTarget && !node.is(util.START)) {\n      return handleKeyNodeMove(node, util.TARGET);\n    }\n    if (userAction === util.PLACING_WALLS && isMouseDown) {\n      return node.setWall();\n    }\n  };\n\n  const onMouseDownHandler = (node) => {\n    setIsMouseDown(true);\n    if (!animating) return;\n    if (userAction === util.ADDING_WEIGHT)\n      return !node.isKeyValue() && node.add(util.WEIGHT);\n    if (userAction === util.ADDING_N_WEIGHT)\n      return !node.isKeyValue() && node.add(util.N_WEIGHT);\n    if (userAction === util.DELETING)\n      return node.remove([util.WALL, util.WEIGHT]);\n    if (!node.isKeyValue()) return node.setWall();\n    if (node.is(util.START)) setIsMovingStart(true);\n    if (node.is(util.TARGET)) setIsMovingTarget(true);\n  };\n\n  const onMouseLeaveHandler = (node) => {\n    if (!animating) return;\n    if (isMovingStart) node.removeClass(util.START);\n    if (isMovingTarget) node.removeClass(util.TARGET);\n  };\n\n  const onMouseUpHandler = () => {\n    // if (!animating) return;\n    setIsMouseDown(false);\n    setIsMovingStart(false);\n    setIsMovingTarget(false);\n  };\n\n  let Grid = nodeGrid.map((row, rowNum) => {\n    return row.map((val, colNum) => {\n      return (\n        <Cell\n          key={val}\n          node={nodeGrid[rowNum][colNum]}\n          mouse={{\n            onMouseEnter: onMouseEnterHandler,\n            onMouseDown: onMouseDownHandler,\n            onMouseUp: onMouseUpHandler,\n            onMouseLeave: onMouseLeaveHandler,\n          }}\n          numRows={numRows}\n          numCols={numCols}\n        />\n      );\n    });\n  });\n\n  const executeAlgorithm = () => {\n    removeVisualization();\n    if (!animating) return;\n    setIsAnimating(false);\n    setPrevAlgorithm(algorithm);\n    setUserAction(util.PLACING_WALLS);\n    resetDistance();\n\n    let animations = [];\n\n    switch (algorithm) {\n      case util.BFS:\n        animations = BFS(true);\n        break;\n      case util.DFS:\n        animations = DFS(true);\n        break;\n      case util.ASTAR:\n        animations = AStar(true);\n        break;\n      case util.DIJKSTRA:\n        animations = Dijkstra(true);\n        break;\n      case util.GREEDY_BFS:\n        animations = bestFirstSearch(true);\n        break;\n      case util.DSTAR:\n        animations = DStar(true);\n        break;\n      case util.PRIMS:\n        animations = Prims(true);\n        break;\n      case util.KRUSKAL:\n        animations = Kruskal();\n        break;\n      case util.FLOYD_WARSHALL:\n        animations = floydWarshall(true);\n        break;\n      case util.BELLMAN_FORD:\n        animations = bellmanFord(true);\n        break;\n      case util.BIDIRECTIONAL_BFS:\n        animations = bidirectionalBFS(true);\n        break;\n      default:\n        animations = BFS(true);\n        break;\n    }\n\n    animate(animations, algorithm);\n  };\n\n  const BFS = (withAnimation) => {\n    const { startNode, graph } = util.generateGraph(nodeGrid);\n    const algExecInfo = graph.bfs(startNode, withAnimation);\n    return algExecInfo;\n  };\n\n  const DFS = (withAnimation) => {\n    const { startNode, graph } = util.generateGraph(nodeGrid);\n    const algExecInfo = graph.dfs(startNode, withAnimation);\n    return algExecInfo;\n  };\n\n  const Dijkstra = (withAnimation) => {\n    const { startNode, graph } = util.generateGraph(nodeGrid);\n    const algExecInfo = graph.dijkstra(startNode, withAnimation);\n    return algExecInfo;\n  };\n\n  const AStar = (withAnimation) => {\n    const { startNode, graph, targetNode } = util.generateGraph(nodeGrid);\n    const algExecInfo = graph.aStar(startNode, targetNode, withAnimation);\n    return algExecInfo;\n  };\n\n  const DStar = (withAnimation) => {\n    const { startNode, graph, targetNode } = util.generateGraph(nodeGrid);\n    const algExecInfo = graph.dStar(startNode, targetNode, withAnimation);\n    return algExecInfo;\n  };\n\n  const floydWarshall = () => {\n    const algExecInfo = util.floydWarshall(nodeGrid);\n    pathMtrx = algExecInfo.kwargs.path;\n    setDistance(algExecInfo.distance);\n    setMatrix(algExecInfo.kwargs.mtrx);\n    return algExecInfo;\n  };\n\n  const bestFirstSearch = (withAnimation) => {\n    const { startNode, graph, targetNode } = util.generateGraph(nodeGrid);\n    const algExecInfo = graph.bestFirstSearch(\n      startNode,\n      targetNode,\n      withAnimation\n    );\n    return algExecInfo;\n  };\n\n  const Prims = (withAnimation) => {\n    const { startNode, graph, targetNode } = util.generateGraph(nodeGrid);\n    const algExecInfo = graph.Prims(startNode, targetNode, withAnimation);\n    return algExecInfo;\n  };\n\n  const Kruskal = () => {\n    const { graph } = util.generateGraph(nodeGrid);\n    const algExecInfo = graph.kruskal();\n    return algExecInfo;\n  };\n\n  const bellmanFord = (withAnimation) => {\n    const { graph, startNode, targetNode } = util.generateGraph(nodeGrid);\n    const algExecInfo = graph.bellmanFord(\n      startNode,\n      targetNode,\n      nodeGrid,\n      withAnimation\n    );\n    return algExecInfo;\n  };\n\n  const bidirectionalBFS = () => {\n    const { graph, startNode, targetNode } = util.generateGraph(nodeGrid);\n    const algExecInfo = graph.bidirectionalBFS(startNode, targetNode);\n    return algExecInfo;\n  };\n\n  const drawPath = (startId, targetId) => {\n    const finalPath = getPath(startId, targetId, pathMtrx);\n    let prevNode = null;\n\n    for (let nodeId of finalPath) {\n      const node = Node.getNode(nodeId, nodeGrid);\n      node.predecessor = prevNode;\n      prevNode = node;\n    }\n    prevNode && prevNode.markShortestPath();\n  };\n\n  const clear = () => {\n    if (!animating) return;\n    setPrevAlgorithm(null);\n    setDistance(util.UNK);\n    setMatrix(null);\n    pathMtrx = null;\n    resetGrid();\n  };\n\n  const removeVisualization = () => {\n    if (!animating) return;\n    setPrevAlgorithm(null);\n    setDistance(util.UNK);\n    removeVisuals();\n  };\n\n  const generateMaze = (type, obj) => {\n    if (!animating) return;\n    clear();\n\n    switch (type) {\n      case util.RECURSIVE_DIVISON:\n        util.recursiveDivision(nodeGrid, obj);\n        break;\n      case util.DRAW_COUNTOUR:\n        util.drawContourWalls(nodeGrid, obj);\n        break;\n      case util.PRIMS_ALGO:\n        const { graph, startNode, targetNode } = util.generateGraph(nodeGrid);\n        util.primsAlgorithm(nodeGrid, startNode, targetNode, graph, obj);\n        break;\n      case util.PRIMS_ALGO_531:\n        const { graph: g, startNode: st, targetNode: t } = util.generateGraph(\n          nodeGrid\n        );\n        util.primsAlgorithm531(nodeGrid, st, t, g, obj);\n        break;\n      default:\n        util.randomMaze(nodeGrid, obj);\n        break;\n    }\n  };\n\n  /**\n   * Animate the animations of the execution of an algorithm.\n   * @param {AlgExecInfo} algExecInfo\n   */\n  const animate = (algExecInfo) => {\n    const { animations, distance, withAnimation } = algExecInfo;\n    if (!withAnimation) return;\n    if (animations.length <= 0) return setIsAnimating(true);\n    let count = 0;\n    let targetNodeRef = null;\n\n    const intervalId = setInterval(() => {\n      const node = animations[count];\n\n      // Weight nodes do not get colored when markSearched is called\n      !node.is(util.WEIGHT) ? node.markSearched() : node.markSearched2Done();\n\n      if (node.is(util.TARGET)) {\n        if (algorithm !== util.FLOYD_WARSHALL) {\n          setDistance(distance);\n        }\n\n        // Save the reference to the target node in Bellmand Ford's\n        if (algorithm === util.BELLMAN_FORD) {\n          targetNodeRef = node;\n        } else {\n          node.markShortestPath();\n        }\n      }\n\n      if (node.is(util.START) && algorithm === util.DSTAR) {\n        node.markShortestPath();\n        setDistance(node.dist);\n      }\n\n      count++;\n\n      if (count >= animations.length) {\n        setIsAnimating(true);\n        clearInterval(intervalId);\n        if (algorithm === util.FLOYD_WARSHALL) {\n          const { startNode, targetNode } = util.getKeyNodes(nodeGrid);\n          drawPath(startNode.id, targetNode.id);\n        }\n        // Animate the final path after marking nodes as visited\n        if (algorithm === BELLMAN_FORD) {\n          targetNodeRef.markShortestPath();\n        }\n      }\n    }, animationSpeed);\n  };\n\n  /**\n   * Wrapper function for setNumRows in useNodeGrid Hook.\n   * It's main purpose is to reset the previous algorithm so that\n   * when user changes grid size, no animations are displayed.\n   * Prevent's user from changing grid size while animation is taking place.\n   * @param {number} numRows\n   */\n  const setRows = (n) => {\n    if (!animating) return;\n    setPrevAlgorithm(null);\n    setNumRows(n);\n  };\n\n  return (\n    <div className=\"text-center\">\n      <Navbar\n        openDialog={openDialog}\n        reset={clear}\n        algorithm={algorithm}\n        executeAlgorithm={executeAlgorithm}\n        clear={removeVisualization}\n        mazeGen={generateMaze}\n        settingSecondTarget={setSettingSecondTarget}\n        setUserAction={setUserAction}\n        setNumRows={setRows}\n        setNumCols={setNumCols}\n        setSpeed={setAnimationSpeed}\n      />\n      <br />\n      <Paper className={classes.paper}>\n        <h2>\n          Click on a Cell to add Walls! You can also drag the target/start!\n        </h2>\n        <h3 style={{ color: \"red\" }}>Distance: {distance} </h3>\n        <p>{util.ALG_TITLE[algorithm]}</p>\n      </Paper>\n      <div\n        className=\"Board\"\n        style={{\n          gridTemplateRows: `repeat(${numRows}, 1fr)`,\n          gridTemplateColumns: `repeat(${numCols}, 1fr)`,\n        }}\n      >\n        {Grid}\n      </div>\n    </div>\n  );\n};\n\nexport default Board;\n","const WALL_PROBABILITY = 0.3\n\nexport const randomMaze = (board, type) => {\n  for (let row in board) {\n    for (let col in board[row]) {\n      const node = board[row][col]\n      if(!node.isKeyValue()) Math.random() <= WALL_PROBABILITY && node.add([type]);\n    }\n  }\n};\n","import React from \"react\";\nimport \"./Backdrop.css\";\n\nconst backdrop = (props) => {\n  const cssClasses = [\n    \"Backdrop\",\n    props.show ? \"BackdropOpen\" : \"BackdropClosed\",\n  ];\n  return <div className={cssClasses.join(\" \")}></div>;\n};\n\nexport default backdrop;\n","import React from \"react\";\nimport {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogContentText,\n  DialogTitle,\n} from \"@material-ui/core\";\nimport PropTypes from \"prop-types\";\nimport Backdrop from \"../Backdrop/Backdrop\";\n\nexport const CustomDialog = ({\n  isOpen,\n  handleClose,\n  title,\n  subtitle,\n  children,\n  howToPlay,\n}) => {\n  return (\n    <>\n      <Dialog\n        fullWidth\n        maxWidth=\"md\"\n        open={isOpen}\n        onClose={handleClose}\n        aria-labelledby=\"max-width-dialog-title\"\n      >\n        <DialogTitle id=\"max-width-dialog-title\">{title}</DialogTitle>\n        <DialogContent>\n          <DialogContentText>{subtitle}</DialogContentText>\n          {children}\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={handleClose} color=\"secondary\">\n            Close\n          </Button>\n        </DialogActions>\n      </Dialog>\n      <Backdrop show={isOpen} />\n    </>\n  );\n};\n\nCustomDialog.propTypes = {\n  isOpen: PropTypes.bool.isRequired,\n  handleClose: PropTypes.func.isRequired,\n  title: PropTypes.string.isRequired,\n  subtitle: PropTypes.string,\n  children: PropTypes.element.isRequired,\n};\n","import React from \"react\";\nimport classes from \"./Footer.module.css\";\nimport github from \"../../resources/logos/github.png\";\n\nconst logoWidth = 40;\nconst Footer = (props) => {\n  return (\n    <>\n      <div className={classes.Footer}>\n        <div className={classes.IconContainer}>\n          <ul className={classes.Icons}>\n            <li className=\"link d-inline-block\" style={{ listStyle: \"none\" }}>\n              <a\n                href=\"https://github.com/luisalfonsopreciado/Graph-Algorithms-Visualization\"\n                rel=\"noopener noreferrer\"\n                className=\"LinkU\"\n                target=\"_blank\"\n              >\n                <img src={github} width={logoWidth} alt=\"github\" />\n              </a>\n            </li>\n          </ul>\n        </div>\n      </div>\n    </>\n  );\n};\nexport default Footer;\n","import { initStore } from \"./store\";\nimport * as cts from \"../utility/constants\";\n\nconst configureStore = () => {\n  const actions = {\n    SET_ALGO: async (state, action) => {\n      state.algorithm = action.algo;\n      return { ...state, algorithm: action.algo };\n    },\n    SET_INFO: async (state, action) => {\n      state.info = action.info;\n      return { ...state, info: action.info };\n    },\n  };\n  initStore(actions, { algorithm: cts.DIJKSTRA, info: cts.DIJKSTRA });\n};\n\nexport default configureStore;\n","import React, { useState, useEffect } from \"react\";\nimport Board from \"./components/Board\";\nimport { CustomDialog } from \"./components/UI/CustomDialog/CustomDialog\";\nimport Paper from \"@material-ui/core/Paper\";\nimport styles from \"./App.module.css\";\nimport Footer from \"./components/Footer/Footer\";\nimport configureAlgorithmStore from \"./hooks-store/algorithm\";\nimport { useStore } from \"./hooks-store/store\";\nimport marked from \"marked\";\nimport { makeStyles } from \"@material-ui/core\";\n\nconfigureAlgorithmStore();\n\nconst useStyles = makeStyles({\n  paper: {\n    padding: \"5px\",\n    margin: \"auto\",\n    width: \"1200px\",\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n  },\n  padding: {\n    padding: \"5px\",\n  },\n});\n\nfunction App() {\n  const [isOpen, setIsOpen] = useState(true);\n  const [markdown, setMarkdown] = useState(null);\n  const [state] = useStore();\n  const classes = useStyles();\n\n  useEffect(() => {\n    const getMarkdown = async () => {\n      const info = await import(`./info/${state.info}.md`);\n      const res = await fetch(info.default);\n      const text = await res.text();\n      const markdown = marked(text);\n      setMarkdown(markdown);\n    };\n    getMarkdown();\n  }, [state.info]);\n\n  useEffect(() => {\n    handleDialogOpen();\n  }, []);\n\n  const handleDialogOpen = () => {\n    setIsOpen(true);\n  };\n\n  const handleDialogClose = () => {\n    setIsOpen(false);\n  };\n\n  return (\n    <>\n      <div className={styles.App}>\n        <Board openDialog={handleDialogOpen} />\n        <Paper className={classes.paper} elevation={10}>\n          <div dangerouslySetInnerHTML={{ __html: markdown }} />\n        </Paper>\n      </div>\n\n      <CustomDialog\n        title=\"\"\n        isOpen={isOpen}\n        handleClose={handleDialogClose}\n        className={styles.customDialog}\n      >\n        <h1>Welcome to The Graph Algorithms Visualizer!</h1>\n        <br />\n        <h4>\n          This Project Helps CS Enthusiasts visualize graph\n          traversal/path-finding algorithms. To get Started, click on an\n          algorithm located on the header and press Visualize!.\n        </h4>\n        <h4>For a better Experience, set your browser to full width</h4>\n      </CustomDialog>\n\n      <Footer />\n    </>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n"],"sourceRoot":""}